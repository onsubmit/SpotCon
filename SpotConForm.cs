//-----------------------------------------------------------------------
// <copyright file="SpotConForm.cs" company="Andy Young">
//     Copyright (c) Andy Young. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace SpotCon
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.DirectoryServices;
    using System.Drawing;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Web;
    using System.Windows.Forms;
    using System.Xml.Linq;
    using SpotCon.DataStructures;
    using SpotCon.Enums;
    using SpotCon.PlaylistImporter;
    using SpotifyWebHelperSharp;
    using SpotifyWebSharp.SpotifyResponses.Lookup;
    using SpotifyWebSharp.SpotifyResponses.Search;
    using SpotifyWebSharp.SpotifyServices;

    /// <summary>
    /// Main form
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.NamingRules", "SA1300:ElementMustBeginWithUpperCaseLetter", Justification = "WinForms autogenerated method names.")]
    [SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1650:ElementDocumentationMustBeSpelledCorrectly", Justification = "'Spotify' is spelled correctly, dummy.")]
    public partial class SpotConForm : Form
    {
        /// <summary>
        /// TCP port to use
        /// </summary>
        private const int Port = 1729;

        /// <summary>
        /// Lock for sending packets
        /// </summary>
        private readonly object sendLock = new object();

        /// <summary>
        /// Lock for receiving packets
        /// </summary>
        private readonly object receiveLock = new object();

        /// <summary>
        /// The name of the current host
        /// </summary>
        private string currentHost;

        /// <summary>
        /// The name of the currently selected host
        /// </summary>
        private string selectedHost;

        /// <summary>
        /// Buffer for server input
        /// </summary>
        private string inputFromServer;

        /// <summary>
        /// Buffer for client input
        /// </summary>
        private string inputFromClient;

        /// <summary>
        /// The current status of Spotify
        /// </summary>
        private Responses.Status currentStatus;

        /// <summary>
        /// The number of milliseconds to wait between each attempt to update status from Spotify
        /// </summary>
        private int defaultWaitTime = 1000;

        /// <summary>
        /// Server listener socket
        /// </summary>
        private Socket listener;

        /// <summary>
        /// Asynchronous callback for server
        /// </summary>
        private AsyncCallback callbackServer;

        /// <summary>
        /// Asynchronous callback for client
        /// </summary>
        private AsyncCallback callbackClient;

        /// <summary>
        /// Temporary placeholder for newly created server worker sockets
        /// </summary>
        private Socket newWorker;

        /// <summary>
        /// Host images
        /// </summary>
        private ImageList hostImages = new ImageList();

        /// <summary>
        /// Popularity images
        /// </summary>
        private ImageList popImages = new ImageList();

        /// <summary>
        /// List of commands that execute in response to client or server requests
        /// </summary>
        private Dictionary<string, Action<string, string, string>> commands;

        /// <summary>
        /// Maps artist name to a Spotify artist href
        /// </summary>
        /// <example>The Naked and Famous|||spotify:artist:0oeUpvxWsC8bWS6SnpU8b9</example>
        private Dictionary<string, string> cachedArtistHrefs = new Dictionary<string, string>();

        /// <summary>
        /// Maps artist name input to actual Spotify artist name
        /// </summary>
        /// <example>Smashing Pumpkins|||The Smashing Pumpkins</example>
        private Dictionary<string, string> misspelledArtists = new Dictionary<string, string>();

        /// <summary>
        /// Maps artist name and track name input to actual Spotify track name
        /// </summary>
        /// <example>spotify:artist:4tZwfgrHOc3mvqYlEYSvVi:::Get Lucky (feat. Pharrell Williams &amp; Nile Rodgers)|||Get Lucky</example>
        private Dictionary<string, string> misspelledTracks = new Dictionary<string, string>();

        /// <summary>
        /// Maps track ID to Lookup Track
        /// </summary>
        private Dictionary<string, Track> cachedLookupTracks = new Dictionary<string, Track>();

        /// <summary>
        /// Maps artist href to Lookup Album
        /// </summary>
        private Dictionary<string, Album> cachedLookupAlbums = new Dictionary<string, Album>();

        /// <summary>
        /// Maps artist (href) and track name combination to Spotify Search Track
        /// </summary>
        /// <example>spotify:artist:3jOstUTkEu2JkjvRdBA5Gu:::Buddy Holly -> SearchTrack serialized on disk</example>
        private Dictionary<string, SearchTrack> cachedSearchTracks = new Dictionary<string, SearchTrack>();

        /// <summary>
        /// Tracks that couldn't be immediately identified by the Search service
        /// </summary>
        private Queue<FindNewTracksThreadStatus> unknownTracks = new Queue<FindNewTracksThreadStatus>();

        /// <summary>
        /// Tracks whose identification process was skipped
        /// </summary>
        private List<string> skippedTracks = new List<string>();

        /// <summary>
        /// Used to retrieve status from Spotify
        /// </summary>
        private Lazy<SpotifyWebHelper> webHelper = new Lazy<SpotifyWebHelper>(() => { return new SpotifyWebHelper(); });

        /// <summary>
        /// Host information
        /// </summary>
        private Dictionary<string, HostData> hostData = new Dictionary<string, HostData>();

        /// <summary>
        /// Server worker sockets
        /// </summary>
        private Dictionary<string, Socket> workers = new Dictionary<string, Socket>();

        /// <summary>
        /// Tracks the list of selected track row indices
        /// </summary>
        private List<int> selectedTrackRowIndices = new List<int>();

        /// <summary>
        /// Handle to Spotify window
        /// </summary>
        private IntPtr spotifyHwnd = IntPtr.Zero;

        /// <summary>
        /// Spotify Search service
        /// </summary>
        private Lazy<SearchService> search = new Lazy<SearchService>(() => { return new SearchService(); });

        /// <summary>
        /// Spotify Lookup service
        /// </summary>
        private Lazy<LookupService> lookup = new Lazy<LookupService>(() => { return new LookupService(); });

        /// <summary>
        /// Tooltip for track
        /// </summary>
        private ToolTip tooltipTrack = new ToolTip();

        /// <summary>
        /// Tooltip for artist
        /// </summary>
        private ToolTip tooltipArtist = new ToolTip();

        /// <summary>
        /// History of actions that can be traversed
        /// </summary>
        private List<Action> history = new List<Action>();

        /// <summary>
        /// Current index in the history
        /// </summary>
        private int historyIndex = 0;

        /// <summary>
        /// Indicates if the form was previously maximized
        /// </summary>
        private bool wasMaximized = false;

        /// <summary>
        /// The relative width of the album data grid
        /// </summary>
        private double albumPercentage;

        /// <summary>
        /// Complete list of tracks returned by a search, lookup, or import
        /// </summary>
        private List<TrackEx> trackDataSet = new List<TrackEx>();

        /// <summary>
        /// Filtered list of tracks to be displayed in the tracks data grid
        /// </summary>
        private List<TrackEx> trackDataSetFiltered = new List<TrackEx>();

        /// <summary>
        /// List of track data grid scroll bar indices that have triggered a search
        /// </summary>
        private List<int> queuedIndices = new List<int>();

        /// <summary>
        /// Queue of terms/page to search for
        /// </summary>
        private Queue<Tuple<string, int?>> searchQueue = new Queue<Tuple<string, int?>>();

        /// <summary>
        /// Reference to the track data grid scroll bar -- used for lazy initlization
        /// </summary>
        private ScrollBar trackScrollBarLazy;

        /// <summary>
        /// IIS process
        /// </summary>
        private Process iisExpress;

        /// <summary>
        /// Initializes a new instance of the SpotConForm class
        /// </summary>
        public SpotConForm()
        {
            this.InitializeComponent();
            this.StartIIS();

            this.commands = new Dictionary<string, Action<string, string, string>>()
            {
                {
                    "|Connected",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        this.workers[orig] = this.newWorker;

                        if (orig != currentHost)
                        {
                            this.SetStatus(string.Format(Properties.Resources.ClientConnected, orig));
                        }
                    })
                },
                {
                    "|Previous",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, AppCommands.WM_APPCOMMAND, 0, AppCommands.APPCOMMAND_MEDIA_PREVIOUSTRACK);
                    })
                },
                {
                    "|Play",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        new BackgroundWorker().QuickStart(() => this.webHelper.Value.Play(s));
                    })
                },
                {
                    "|Next",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, AppCommands.WM_APPCOMMAND, 0, AppCommands.APPCOMMAND_MEDIA_NEXTTRACK);
                    })
                },
                {
                    "|Pause",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, AppCommands.WM_APPCOMMAND, 0, AppCommands.APPCOMMAND_MEDIA_PLAY_PAUSE);
                    })
                },
                {
                    "|SetVolume",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        string[] split = s.Split(':');
                        double desired = 0;
                        double.TryParse(split[0], out desired);

                        double current = 0;
                        double.TryParse(split[1], out current);

                        string action = desired < current ? "{DOWN}" : "{UP}";

                        bool success = SetForegroundWindow(this.spotifyHwnd);
                        for (int i = 0; i <= 100 * Math.Abs((desired - current) / 6.25); i++)
                        {
                            System.Threading.Thread.Sleep(10);
                            SendKeys.Send(string.Format("^({0})", action));
                            System.Threading.Thread.Sleep(10);
                        }

                        if (dest == this.currentHost)
                        {
                            success = SetForegroundWindow(this.Handle);
                        }
                    })
                },
                {
                    "|GetStatusFromServer",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        new BackgroundWorker().QuickStart(() =>
                        {
                            string response = string.Empty;
                            webHelper.Value.GetStatus(out response);
                            this.SendToClient(response + "|ServerStatusReturned", orig);
                        });
                    })
                },
                {
                    "|ServerStatusReturned",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        Responses.Status status = webHelper.Value.Deserialize<Responses.Status>(s);
                        bool success = this.UpdateStatus(status);
                        string currentAlbumUri = this.currentStatus == null || this.currentStatus.Track == null ? null : this.currentStatus.Track.AlbumResource.Uri;
                        this.currentStatus = status;

                        if (success && status.Track.AlbumResource.Uri != currentAlbumUri)
                        {
                            BackgroundWorker bw = new BackgroundWorker();
                            bw.DoWork += (bwSender, bwArgs) =>
                            {
                                Tuple<string, string> art = webHelper.Value.GetArt(status.Track);
                                bwArgs.Result = art;
                            };

                            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
                            {
                                Tuple<string, string> art = bwArgs.Result as Tuple<string, string>;
                                pictureBox.LoadAsync(art.Item2);
                            };

                            bw.RunWorkerAsync();
                        }
                    })
                }
            };
        }

        /// <summary>
        /// Gets a reference to the track data grid scroll bar
        /// </summary>
        private ScrollBar trackScrollBar
        {
            get
            {
                if (this.trackScrollBarLazy == null)
                {
                    Type type = this.dataGridViewTracks.GetType();
                    PropertyInfo pi = type.GetProperty("VerticalScrollBar", BindingFlags.Instance | BindingFlags.NonPublic);
                    this.trackScrollBarLazy = pi.GetValue(this.dataGridViewTracks, null) as ScrollBar;
                }

                return this.trackScrollBarLazy;
            }
        }

        /// <summary>
        /// Sends the specified message to a window or windows.
        /// The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose window procedure will receive the message.</param>
        /// <param name="msg">The message to be sent.</param>
        /// <param name="wParam">Additional message-specific information. (UINT_PTR)</param>
        /// <param name="lParam">Additional message-specific information. (LONG_PTR)</param>
        /// <returns>The return value specifies the result of the message processing; it depends on the message sent.</returns>
        [DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint msg, int wParam, int lParam);

        /// <summary>
        /// Brings the thread that created the specified window into the foreground and activates the window.
        /// </summary>
        /// <param name="hWnd">A handle to the window that should be activated and brought to the foreground.</param>
        /// <returns>If the window was brought to the foreground, the return value is nonzero. Zero otherwise.</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        /// <summary>
        /// Examines the Z order of the child windows associated with the specified parent window and retrieves a handle to the child window at the top of the Z order.
        /// </summary>
        /// <param name="hWnd">A handle to the parent window whose child windows are to be examined. If this parameter is NULL, the function returns a handle to the window at the top of the Z order.</param>
        /// <returns>If the function succeeds, the return value is a handle to the child window at the top of the Z order. If the specified window has no child windows, the return value is NULL.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr GetTopWindow(IntPtr hWnd);

        /// <summary>
        /// Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.
        /// </summary>
        /// <param name="hWnd">A handle to a window. The window handle retrieved is relative to this window, based on the value of the uCmd parameter.</param>
        /// <param name="uCmd">The relationship between the specified window and the window whose handle is to be retrieved.</param>
        /// <returns>If the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the specified window, the return value is NULL.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr GetWindow(IntPtr hWnd, uint uCmd);

        /// <summary>
        /// Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.
        /// </summary>
        /// <param name="hwnd">A handle to the window.</param>
        /// <param name="lpdwProcessId">A pointer to a variable that receives the process identifier. If this parameter is not NULL, GetWindowThreadProcessId copies the identifier of the process to the variable; otherwise, it does not.</param>
        /// <returns>The return value is the identifier of the thread that created the window.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint GetWindowThreadProcessId(IntPtr hwnd, out uint lpdwProcessId);

        /// <summary>
        /// Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose window procedure is to receive the message. The following values have special meanings.</param>
        /// <param name="msg">The message to be posted.</param>
        /// <param name="wParam">Additional message-specific information. (UINT_PTR)</param>
        /// <param name="lParam">Additional message-specific information. (LONG_PTR)</param>
        /// <returns>If the function succeeds, the return value is nonzero.</returns>
        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool PostMessage(HandleRef hWnd, uint msg, IntPtr wParam, IntPtr lParam);

        /// <summary>
        /// Starts the SpotCon web service in IIS Express
        /// </summary>
        private void StartIIS()
        {
            ProcessStartInfo start = new ProcessStartInfo()
            {
                FileName = Path.Combine(Environment.GetEnvironmentVariable("ProgramW6432"), "IIS Express", "iisexpress.exe"),
                Arguments = @"/config:WebService\applicationhost.config /systray:true",
                WorkingDirectory = Directory.GetCurrentDirectory(),
                UseShellExecute = false,
                CreateNoWindow = true
            };

            this.iisExpress = Process.Start(start);
        }

        /// <summary>
        /// Invoked when a new client connects
        /// </summary>
        /// <param name="result">Connection result</param>
        private void OnClientConnect(IAsyncResult result)
        {
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                try
                {
                    // Complete the BeginAccept() asynchronous call by calling EndAccept() which returns a reference to the new socket
                    Socket socket = this.listener.EndAccept(result);
                    this.newWorker = socket;

                    // Let the worker socket do further processing for the just connected client
                    WaitForDataServer(socket);

                    // Since the main socket is now free, it can go back and wait for other clients who are attempting to connect
                    listener.BeginAccept(new AsyncCallback(OnClientConnect), null);
                }
                catch (ObjectDisposedException)
                {
                    System.Diagnostics.Debugger.Log(0, "1", "\n OnClientConnection: Socket has been closed\n");
                }
                catch (Exception ex)
                {
                    bwArgs.Result = ex;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (bwArgs.Result is Exception && this.InvokeRequired)
                {
                    this.BeginInvoke((Delegate)(new Action(() => this.SetStatusError((bwArgs.Result as Exception).Message))));
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Invoked when data is received by the server
        /// </summary>
        /// <param name="result">Data result</param>
        private void OnDataReceivedByServer(IAsyncResult result)
        {
            SocketPacket packet = (SocketPacket)result.AsyncState;

            // Complete the BeginReceive() asynchronous call by the EndReceive() method which will return the number of characters written to the stream by the client
            if (packet.Socket.Connected)
            {
                lock (this.receiveLock)
                {
                    int byteCount = 0;
                    try
                    {
                        byteCount = packet.Socket.EndReceive(result);
                    }
                    catch (SocketException)
                    {
                        return;
                    }

                    char[] chars = new char[byteCount];
                    int charLen = Encoding.UTF8.GetChars(bytes: packet.Buffer, byteIndex: 0, byteCount: byteCount, chars: chars, charIndex: 0);
                    string data = new string(chars);
                    this.inputFromClient += data;

                    foreach (var command in this.commands)
                    {
                        if (this.inputFromClient.EndsWith(command.Key))
                        {
                            string input = this.inputFromClient.Replace(command.Key, string.Empty);
                            this.inputFromClient = string.Empty;

                            string[] split = input.Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                            string originatingClient = split[0];
                            input = split.Length > 1 ? split[1] : string.Empty;

                            if (this.InvokeRequired)
                            {
                                this.BeginInvoke((Delegate)command.Value, this.currentHost, originatingClient, input);
                            }

                            break;
                        }
                    }

                    // Continue the waiting for data on the socket
                    this.WaitForDataServer(packet.Socket);
                }
            }
        }

        /// <summary>
        /// Invoked when data is received by the client
        /// </summary>
        /// <param name="result">Data result</param>
        private void OnDataReceivedByClient(IAsyncResult result)
        {
            SocketPacket packet = (SocketPacket)result.AsyncState;

            // Complete the BeginReceive() asynchronous call by the EndReceive() method which will return the number of characters written to the stream by the client
            if (packet.Socket.Connected)
            {
                lock (this.receiveLock)
                {
                    int byteCount = 0;
                    try
                    {
                        byteCount = packet.Socket.EndReceive(result);
                    }
                    catch (SocketException)
                    {
                        return;
                    }

                    char[] chars = new char[byteCount];
                    int charLen = Encoding.UTF8.GetChars(bytes: packet.Buffer, byteIndex: 0, byteCount: byteCount, chars: chars, charIndex: 0);
                    string data = new string(chars);
                    this.inputFromServer += data;

                    foreach (var command in this.commands)
                    {
                        if (this.inputFromServer.EndsWith(command.Key))
                        {
                            string input = this.inputFromServer.Replace(command.Key, string.Empty);
                            this.inputFromServer = string.Empty;

                            string[] split = input.Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                            string originatingServer = split[0];
                            input = split.Length > 1 ? split[1] : string.Empty;

                            if (this.InvokeRequired)
                            {
                                this.BeginInvoke((Delegate)command.Value, this.currentHost, originatingServer, input);
                            }

                            break;
                        }
                    }

                    // Continue the waiting for data on the socket
                    this.WaitForDataClient(packet.Socket);
                }
            }
        }

        /// <summary>
        /// Invoked when the server begins waiting for data
        /// </summary>
        /// <param name="socket">Server socket</param>
        private void WaitForDataServer(Socket socket)
        {
            try
            {
                if (this.callbackServer == null)
                {
                    // Specify the callback function which is to be invoked when there is any write activity by the connected client
                    this.callbackServer = new AsyncCallback(this.OnDataReceivedByServer);
                }

                SocketPacket socketPacket = new SocketPacket() { Socket = socket };

                // Start receiving any data written by the connected client asynchronously
                socket.BeginReceive(buffer: socketPacket.Buffer, offset: 0, size: socketPacket.Buffer.Length, socketFlags: SocketFlags.None, callback: this.callbackServer, state: socketPacket);
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Invoked when the client begins waiting for data
        /// </summary>
        /// <param name="socket">Client socket</param>
        private void WaitForDataClient(Socket socket)
        {
            try
            {
                if (this.callbackClient == null)
                {
                    // Specify the callback function which is to be invoked when there is any write activity by the connected client
                    this.callbackClient = new AsyncCallback(this.OnDataReceivedByClient);
                }

                SocketPacket socketPacket = new SocketPacket() { Socket = socket };

                // Start receiving any data written by the connected client asynchronously
                socket.BeginReceive(buffer: socketPacket.Buffer, offset: 0, size: socketPacket.Buffer.Length, socketFlags: SocketFlags.None, callback: this.callbackClient, state: socketPacket);
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// SpotConForm Load event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_Load(object sender, EventArgs e)
        {
            this.history.Add(() =>
            {
                this.trackDataSet.Clear();
                this.trackDataSetFiltered.Clear();
                this.PopulateTracks();
                this.PopulateArtistFilter();
                this.PopulateAlbumFilter();
                this.ClearStatus();
            });

            this.panelBack.Tag = false;
            this.panelForward.Tag = false;

            this.ActiveControl = this.panelPlayPause;
            this.textBoxSearch.Tag = this.textBoxSearch.ForeColor;

            this.ClearStatus();
            this.SetStatusBusy(Properties.Resources.SearchingNetwork);

            this.hostImages.Images.Add(Properties.Resources.Computer);
            this.hostImages.Images.Add(Properties.Resources.ComputerLink);
            this.hostImages.Images.Add(Properties.Resources.ComputerError);

            this.popImages.ImageSize = new Size(65, 8);
            this.popImages.Images.Add(Properties.Resources.pop00);
            this.popImages.Images.Add(Properties.Resources.pop01);
            this.popImages.Images.Add(Properties.Resources.pop02);
            this.popImages.Images.Add(Properties.Resources.pop03);
            this.popImages.Images.Add(Properties.Resources.pop04);
            this.popImages.Images.Add(Properties.Resources.pop05);
            this.popImages.Images.Add(Properties.Resources.pop06);
            this.popImages.Images.Add(Properties.Resources.pop07);
            this.popImages.Images.Add(Properties.Resources.pop08);
            this.popImages.Images.Add(Properties.Resources.pop09);
            this.popImages.Images.Add(Properties.Resources.pop10);
            this.popImages.Images.Add(Properties.Resources.pop11);
            this.popImages.Images.Add(Properties.Resources.pop12);
            this.popImages.Images.Add(Properties.Resources.pop13);
            this.popImages.Images.Add(Properties.Resources.pop14);
            this.popImages.Images.Add(Properties.Resources.pop15);
            this.popImages.Images.Add(Properties.Resources.pop16);
            this.popImages.Images.Add(Properties.Resources.pop17);
            this.popImages.Images.Add(Properties.Resources.pop18);
            this.popImages.Images.Add(Properties.Resources.pop19);
            this.popImages.Images.Add(Properties.Resources.pop20);
            this.popImages.Images.Add(Properties.Resources.pop21);
            this.popImages.Images.Add(Properties.Resources.pop22);

            Directory.CreateDirectory(Path.Combine(Application.UserAppDataPath, "Lookup", "Tracks"));
            Directory.CreateDirectory(Path.Combine(Application.UserAppDataPath, "Lookup", "Albums"));
            Directory.CreateDirectory(Path.Combine(Application.UserAppDataPath, "Search"));
            this.LoadImportPlugins();
            this.LoadPlaylists();
            this.ReadArtistCache();
            this.ReadMisspelledArtistCache();
            this.ReadMisspelledTrackCache();
            this.ReadCachedTracks();

            this.albumPercentage = (double)this.dataGridViewAlbums.Width / (double)this.dataGridViewTracks.Width;

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                try
                {
                    listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                    // Bind to local IP address
                    IPEndPoint ipLocal = new IPEndPoint(IPAddress.Any, Port);
                    listener.Bind(ipLocal);

                    // Start listening
                    listener.Listen(backlog: 4);

                    // Create the call back for any client connections...
                    listener.BeginAccept(new AsyncCallback(OnClientConnect), state: null);

                    this.currentHost = Dns.GetHostName().ToUpper();

                    List<string> names;
                    if (Properties.Settings.Default.HostNames == null || Properties.Settings.Default.HostNames.Count == 0)
                    {
                        DirectoryEntry entry = new DirectoryEntry("WinNT:");
                        names = (from DirectoryEntry domains in entry.Children
                                 from DirectoryEntry pc in domains.Children
                                 where pc.SchemaClassName.ToLower().Contains("computer")
                                 select pc.Name.ToUpper()).ToList();

                        if (!names.Any())
                        {
                            names.Add(this.currentHost);
                        }

                        StringCollection sc = new StringCollection();
                        sc.AddRange(names.ToArray());

                        Properties.Settings.Default.HostNames = sc;
                        Properties.Settings.Default.Save();
                        bwArgs.Result = names;
                    }
                    else
                    {
                        bwArgs.Result = names = Properties.Settings.Default.HostNames.Cast<string>().ToList();
                    }

                    foreach (var name in names)
                    {
                        try
                        {
                            if (name.Equals(this.currentHost, StringComparison.OrdinalIgnoreCase))
                            {
                                this.hostData[name] = new HostData() { IPAddress = Dns.GetHostAddresses(name).FirstOrDefault(i => i.AddressFamily == AddressFamily.InterNetwork) };
                            }
                            else
                            {
                                this.hostData[name] = null;
                            }
                        }
                        catch
                        {
                        }
                    }
                }
                catch (Exception ex)
                {
                    bwArgs.Result = ex;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.ClearStatus();
                this.SetBusyState(false);

                if (bwArgs.Result is Exception)
                {
                    Exception ex = bwArgs.Result as Exception;
                    this.SetStatusError(ex.Message);
                    return;
                }
                else
                {
                    List<string> names = bwArgs.Result as List<string>;
                    foreach (var name in names)
                    {
                        try
                        {
                            if (this.hostData.ContainsKey(name))
                            {
                                DataGridViewRow row = new DataGridViewRow();
                                bool connected = name.Equals(this.currentHost, StringComparison.OrdinalIgnoreCase);
                                Bitmap connectedImage = connected ? Properties.Resources.CheckboxChecked : Properties.Resources.Checkbox;
                                row.CreateCells(this.dataGridViewComputers, connectedImage, hostImages.Images[(int)ClientConnectStatus.Disconnected], name);
                                row.Cells[(int)HostColumns.Checkbox].Tag = connected;
                                row.Height = 28;

                                int index = this.dataGridViewComputers.Rows.Add(row);
                                this.hostData[name].Row = dataGridViewComputers.Rows[index];
                            }
                            else
                            {
                                // TODO: Why is there an empty "else" here?
                            }
                        }
                        catch
                        {
                        }
                    }

                    bool exit = false;
                    Process[] processes = null;

                    while (!exit)
                    {
                        processes = Process.GetProcessesByName("spotify");
                        if (processes.Any())
                        {
                            this.spotifyHwnd = processes[0].MainWindowHandle;
                            break;
                        }

                        if (DialogResult.Cancel == MessageBox.Show(this, Properties.Resources.SpotifyNotFound, this.Text, MessageBoxButtons.RetryCancel, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1))
                        {
                            exit = true;
                        }
                    }

                    if (exit)
                    {
                        Application.Exit();
                    }

                    GlobalMouseHandler globalClick = new GlobalMouseHandler()
                    {
                        BackAction = () => this.GoBack(),
                        ForwardAction = () => this.GoForward()
                    };

                    Application.AddMessageFilter(globalClick);

                    if (names.Contains(this.currentHost))
                    {
                        this.selectedHost = this.currentHost;
                        this.ConnectToServer((int)HostColumns.Checkbox, this.hostData[this.currentHost].Row.Index, this.currentHost);
                    }
                }
            };

            bw.RunWorkerAsync(bw);
        }

        /// <summary>
        /// Loads the playlists from the cache
        /// </summary>
        private void LoadPlaylists()
        {
            if (Properties.Settings.Default.Playlists != null)
            {
                this.dataGridViewPlaylists.SelectionChanged -= this.dataGridViewPlaylists_SelectionChanged;

                Dictionary<string, PlaylistEx> playlists = this.GetPlaylistCache();
                foreach (var p in playlists)
                {
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewPlaylists, p.Value.Name);
                    row.Tag = p.Value;
                    this.dataGridViewPlaylists.Rows.Add(row);
                    row.Selected = false;
                }

                this.dataGridViewPlaylists.SelectionChanged += this.dataGridViewPlaylists_SelectionChanged;
            }
        }

        /// <summary>
        /// Gets the playlist cache
        /// </summary>
        /// <returns>Playlist cache</returns>
        private Dictionary<string, PlaylistEx> GetPlaylistCache()
        {
            StringCollection sc = Properties.Settings.Default.Playlists;
            Dictionary<string, PlaylistEx> playlists = new Dictionary<string, PlaylistEx>();

            if (sc != null)
            {
                string[] split = null;
                playlists = sc.Cast<string>().ToDictionary(s => (split = s.Split(new[] { "|||" }, StringSplitOptions.None))[0], s => new PlaylistEx(split[0], split[1], split[2].Split(",".ToCharArray(), StringSplitOptions.RemoveEmptyEntries).ToList()));
            }

            return playlists;
        }

        /// <summary>
        /// Adds the given playlist the the playlist cache
        /// </summary>
        /// <param name="playlist">Playlist to add</param>
        private void AddToPlaylistCache(PlaylistEx playlist)
        {
            StringCollection sc = Properties.Settings.Default.Playlists ?? new StringCollection();
            sc.Add(string.Format("{0}|||{1}|||{2}", playlist.Uri, playlist.Name, string.Join(",", playlist.Tracks)));
            Properties.Settings.Default.Playlists = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Updates an extisting cached playlist entry
        /// </summary>
        /// <param name="playlist">Playlist to update</param>
        private void UpdatePlaylistCache(PlaylistEx playlist)
        {
            Dictionary<string, PlaylistEx> playlists = this.GetPlaylistCache();
            playlists[playlist.Uri] = playlist;
            this.ReplacePlaylistCache(playlists);
        }

        /// <summary>
        /// Replaces the playlist cache
        /// </summary>
        /// <param name="playlists">New playlists to write out to the cache</param>
        private void ReplacePlaylistCache(Dictionary<string, PlaylistEx> playlists)
        {
            StringCollection sc = new StringCollection();
            foreach (var playlist in playlists.Values)
            {
                sc.Add(string.Format("{0}|||{1}|||{2}", playlist.Uri, playlist.Name, string.Join(",", playlist.Tracks)));
            }

            Properties.Settings.Default.Playlists = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Loads any playlist import plugins
        /// </summary>
        private void LoadImportPlugins()
        {
            Type pluginType = typeof(IPlaylistImporter);
            var plugins = new List<IPlaylistImporter>();
            foreach (string filename in Directory.GetFiles(".\\Plugins", "*.dll"))
            {
                Assembly currentAssembly = Assembly.LoadFrom(filename);
                foreach (Type type in currentAssembly.GetExportedTypes().Where(t => t.GetInterface(pluginType.FullName) != null))
                {
                    try
                    {
                        IPlaylistImporter plugin = (IPlaylistImporter)Assembly.GetAssembly(pluginType).CreateInstance(
                            typeName: type.FullName,
                            args: null,
                            ignoreCase: false,
                            bindingAttr: BindingFlags.CreateInstance,
                            binder: null,
                            culture: null,
                            activationAttributes: null);

                        plugins.Add(plugin);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(this, ex.ToString(), Properties.Resources.PluginLoadError, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }

            foreach (var plugin in plugins)
            {
                ToolStripItem item = toolStripMenuItemImportPlaylist.DropDownItems.Add(plugin.MenuItem);
                item.Click += (sender, e) =>
                {
                    plugin.MainForm.ShowDialog(this);
                    this.FindNewTracks(plugin);
                };
            }
        }

        /// <summary>
        /// Finds new tracks from the given playlist import plugin
        /// </summary>
        /// <param name="plugin">Playlist import plugin</param>
        private void FindNewTracks(IPlaylistImporter plugin)
        {
            BackgroundWorker bw = new BackgroundWorker()
            {
                WorkerReportsProgress = true,
                WorkerSupportsCancellation = true
            };

            bw.DoWork += (bwSender, bwArgs) =>
            {
                Regex regex = null;
                try
                {
                    regex = new Regex(plugin.ArtistTrackRegex);
                }
                catch (ArgumentException aex)
                {
                    FindNewTracksThreadStatus status = new FindNewTracksThreadStatus()
                    {
                        Message = aex.Message,
                        Status = FindNewTracksStatus.InvalidRegex
                    };

                    bw.ReportProgress(0, status);
                    return;
                }

                // Distinct tracks only
                plugin.Tracks = plugin.Tracks.Distinct().ToList();
                for (int i = 0; !bw.CancellationPending && i < plugin.Tracks.Count; i++)
                {
                    bw.ReportProgress(0, new FindNewTracksThreadStatus() { Counter = i, Maximum = plugin.Tracks.Count });

                    Match match = regex.Match(plugin.Tracks[i]);
                    FindNewTracksThreadStatus status = new FindNewTracksThreadStatus()
                    {
                        Counter = i,
                        Maximum = plugin.Tracks.Count,
                        Message = plugin.Tracks[i],
                        Status = FindNewTracksStatus.AddNewTrack
                    };

                    if (!match.Success)
                    {
                        status.Status = FindNewTracksStatus.ParseError;
                        bw.ReportProgress(0, status);
                        continue;
                    }

                    if (!bw.CancellationPending)
                    {
                        status.ArtistName = match.Groups["ARTIST"].Value.Trim();
                        status.TrackName = match.Groups["TRACK"].Value.Trim();

                        this.GetArtist(status);
                        this.GetTrack(status);

                        bw.ReportProgress(0, status);
                    }
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                FindNewTracksThreadStatus status = bwArgs.UserState as FindNewTracksThreadStatus;

                this.SetStatus(string.Format("Looking up track {0} of {1}...", status.Counter + 1, status.Maximum));
                this.SetProgressBar(status.Counter);

                switch (status.Status)
                {
                    case FindNewTracksStatus.InvalidRegex:
                        if (DialogResult.Cancel == MessageBox.Show(status.Message, "Regex error", MessageBoxButtons.OKCancel, MessageBoxIcon.Error))
                        {
                            bw.CancelAsync();
                        }

                        break;
                    case FindNewTracksStatus.ParseError:
                        if (DialogResult.Cancel == MessageBox.Show(string.Format("Could not parse song information from <{0}>", status.Message), "Parse error", MessageBoxButtons.OKCancel, MessageBoxIcon.Error))
                        {
                            bw.CancelAsync();
                        }

                        break;
                    case FindNewTracksStatus.UnknownArtist:
                    case FindNewTracksStatus.UnknownTrack:
                        unknownTracks.Enqueue(status);
                        break;
                    case FindNewTracksStatus.AddNewTrack:
                        this.AddNewTrack(status);
                        break;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.ClearStatus();
                this.HideProgressBar();
                this.SetBusyState(false);

                if (this.unknownTracks.Any())
                {
                    this.GetUnknownInfo(this.unknownTracks.Dequeue());
                }
                else
                {
                    this.FindNewTracksEnd();
                }
            };

            this.SetBusyState(true);
            this.unknownTracks.Clear();
            this.dataGridViewTracks.Rows.Clear();
            this.SetProgressBar(1, plugin.Tracks.Count);
            bw.RunWorkerAsync(plugin.Tracks);
        }

        /// <summary>
        /// Runs after the user is done finding new tracks
        /// </summary>
        private void FindNewTracksEnd()
        {
            if (this.skippedTracks.Any() &&
                DialogResult.Yes == MessageBox.Show(
                    Properties.Resources.SkippedTracksClipboard,
                    Properties.Resources.SkippedTracksClipboardCaption,
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning))
            {
                Clipboard.SetText(string.Join(Environment.NewLine, this.skippedTracks));
            }

            this.SaveArtistCache();
            this.SaveSearchTrackCache();
            this.SaveMisspelledArtistCache();
            this.SaveMisspelledTrackCache();
            this.SetBusyState(false);
        }

        /// <summary>
        /// Gets missing info when a search query doesn't return an exact match
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownInfo(FindNewTracksThreadStatus unknownTrack)
        {
            if (unknownTrack.Status == FindNewTracksStatus.UnknownArtist)
            {
                this.GetUnknownArtist(unknownTrack);
            }
            else if (unknownTrack.Status == FindNewTracksStatus.UnknownTrack)
            {
                this.GetUnknownTrackThreadSafe(unknownTrack);
            }
        }

        /// <summary>
        /// Gets track information when no exact match is found for the track
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownTrack(FindNewTracksThreadStatus unknownTrack)
        {
            List<SearchTrack> trackList = unknownTrack.Tracks.TrackList;
            var artistQuery = unknownTrack.Tracks.TrackList.Where(t => t.Artist.Href == unknownTrack.ArtistHref);
            if (artistQuery.Any())
            {
                trackList = artistQuery.ToList();
            }

            string originalTrack = unknownTrack.TrackName;
            UnknownTrack ut = new UnknownTrack(unknownTrack.ArtistName, unknownTrack.ArtistHref, unknownTrack.TrackName, trackList);
            if (ut.ShowDialog(this) == DialogResult.Cancel)
            {
                unknownTrack.Status = FindNewTracksStatus.Cancel;
                this.FindNewTracksEnd();
                return;
            }

            if (ut.SelectedTrack != null)
            {
                unknownTrack.Track = ut.SelectedTrack;
                string misspelledKey = string.Format("{0}:::{1}", unknownTrack.ArtistHref, originalTrack);

                if (unknownTrack.Track.Original is Track)
                {
                    Track track = unknownTrack.Track.Original as Track;
                    this.misspelledTracks[misspelledKey] = track.Name;
                    this.cachedLookupTracks.Add(track.Id.Value, track);

                    string path = Path.Combine(Application.UserAppDataPath, "Lookup", "Tracks", track.Href.Replace("spotify:track:", string.Empty) + ".xml");
                    SpotifyService.Serialize(track, path);
                }
                else if (unknownTrack.Track.Original is SearchTrack)
                {
                    XDocument doc = new XDocument();
                    SearchTrack track = unknownTrack.Track.Original as SearchTrack;
                    this.misspelledTracks[misspelledKey] = track.Name;

                    string path = Path.Combine(Application.UserAppDataPath, "Search", unknownTrack.ArtistHref.Replace("spotify:artist:", string.Empty) + ".xml");

                    XElement trackNode = new XElement(
                        "Track",
                        new XAttribute("Query", unknownTrack.TrackName),
                        HttpUtility.HtmlEncode(SpotifyService.Serialize(track)));

                    if (File.Exists(path))
                    {
                        doc = XDocument.Load(path);
                        doc.Root.Add(trackNode);
                    }
                    else
                    {
                        doc = new XDocument(new XElement("Tracks", trackNode));
                    }

                    doc.Save(path);
                }
            }
            else
            {
                unknownTrack.Status = FindNewTracksStatus.TrackSkipped;
                this.skippedTracks.Add(unknownTrack.Message);
            }
        }

        /// <summary>
        /// Gets artist information when no exact match is found for the artist
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownArtist(FindNewTracksThreadStatus unknownTrack)
        {
            if (unknownTrack.ArtistHref == null)
            {
                string originalArtist = unknownTrack.ArtistName;
                UnknownArtist ua = new UnknownArtist(unknownTrack.ArtistName, unknownTrack.Artists);
                if (ua.ShowDialog(this) == DialogResult.Cancel)
                {
                    unknownTrack.Status = FindNewTracksStatus.Cancel;
                    this.FindNewTracksEnd();
                    return;
                }

                if (ua.SelectedArtist != null)
                {
                    unknownTrack.Artist = ua.SelectedArtist;

                    unknownTrack.ArtistName = unknownTrack.Artist.Name;
                    unknownTrack.ArtistHref = unknownTrack.Artist.Href;
                    this.misspelledArtists[originalArtist] = unknownTrack.ArtistName;
                    this.cachedArtistHrefs[unknownTrack.ArtistName] = unknownTrack.Artist.Href;

                    this.GetUnknownTrackThreadSafe(unknownTrack);
                }
                else
                {
                    unknownTrack.Status = FindNewTracksStatus.TrackSkipped;
                    this.skippedTracks.Add(unknownTrack.Message);
                    if (this.unknownTracks.Any())
                    {
                        this.GetUnknownInfo(this.unknownTracks.Dequeue());
                    }
                    else
                    {
                        this.FindNewTracksEnd();
                    }
                }
            }
        }

        /// <summary>
        /// Gets track information
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownTrackThreadSafe(FindNewTracksThreadStatus unknownTrack)
        {
            BackgroundWorker bw = new BackgroundWorker();

            bw.DoWork += (bwSender, bwArgs) =>
            {
                this.GetTrack(unknownTrack);

                if (unknownTrack.Tracks == null)
                {
                    unknownTrack.Tracks = this.search.Value.SearchTracks(unknownTrack.TrackName);
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (unknownTrack.Status != FindNewTracksStatus.TrackSkipped)
                {
                    this.GetUnknownTrack(unknownTrack);
                }

                if (unknownTrack.Status == FindNewTracksStatus.Cancel)
                {
                    return;
                }

                if (unknownTrack.Status != FindNewTracksStatus.TrackSkipped)
                {
                    this.AddNewTrack(unknownTrack);
                }

                if (this.unknownTracks.Any())
                {
                    this.GetUnknownInfo(this.unknownTracks.Dequeue());
                }
                else
                {
                    this.FindNewTracksEnd();
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Adds a new track to the track gird
        /// </summary>
        /// <param name="status">FindNewTracks thread status</param>
        private void AddNewTrack(FindNewTracksThreadStatus status)
        {
            DataGridViewRow row = new DataGridViewRow();
            row.CreateCells(this.dataGridViewTracks, status.Track.DiscNumber, status.Track.TrackNumber, status.Track.Name, status.Track.Artist.Name, TimeSpan.FromSeconds(status.Track.Length).ToString(@"m\:ss"), this.GetPopularityImage(status.Track.Popularity), status.Track.Album.Name);
            row.Cells[(int)TrackColumns.Popularity].Tag = status.Track.Popularity;
            row.Cells[(int)TrackColumns.Time].Tag = status.Track.Length;
            row.Tag = status.Track;
            row.Height = 42;

            this.dataGridViewTracks.Rows.Add(row);
        }

        /// <summary>
        /// Gets the Spotify artist
        /// </summary>
        /// <param name="status">Thread status object</param>
        private void GetArtist(FindNewTracksThreadStatus status)
        {
            string artistName = status.ArtistName;
            bool artistFound = this.cachedArtistHrefs.ContainsKey(artistName);

            if (!artistFound && this.misspelledArtists.ContainsKey(artistName))
            {
                artistName = this.misspelledArtists[artistName];
                artistFound = this.cachedArtistHrefs.ContainsKey(artistName);
            }

            if (artistFound)
            {
                status.ArtistHref = this.cachedArtistHrefs[artistName];
            }
            else
            {
                status.Artists = this.search.Value.SearchArtists(artistName);
                var artistQuery = status.Artists.ArtistList.Where(a => a.Name.Equals(artistName, System.StringComparison.OrdinalIgnoreCase));
                if (!artistQuery.Any())
                {
                    status.Status = FindNewTracksStatus.UnknownArtist;
                }
                else
                {
                    status.Artist = artistQuery.First();
                }

                if (status.Artist != null)
                {
                    this.cachedArtistHrefs[artistName] = status.Artist.Href;
                    status.ArtistName = status.Artist.Name;
                    status.ArtistHref = status.Artist.Href;
                }
            }
        }

        /// <summary>
        /// Gets the Spotify track
        /// </summary>
        /// <param name="status">Thread status object</param>
        private void GetTrack(FindNewTracksThreadStatus status)
        {
            if (status.ArtistHref == null)
            {
                return;
            }

            SearchTrack track = null;
            string trackName = status.TrackName;
            string key = string.Format("{0}:::{1}", status.ArtistHref, trackName);

            bool trackFound = this.cachedSearchTracks.ContainsKey(key);
            if (!trackFound && this.misspelledTracks.ContainsKey(key))
            {
                trackName = this.misspelledTracks[key];
                key = string.Format("{0}:::{1}", status.ArtistHref, trackName);
                trackFound = this.cachedSearchTracks.ContainsKey(key);
            }

            if (trackFound && (track = this.cachedSearchTracks[key]) != null)
            {
                status.Track = new TrackEx(track);
            }
            else
            {
                XDocument doc = null;
                string path = Path.Combine(Application.UserAppDataPath, "Search", status.ArtistHref.Replace("spotify:artist:", string.Empty) + ".xml");
                if (File.Exists(path))
                {
                    doc = XDocument.Load(path);
                    var trackNode = from node in doc.Root.Elements("Track")
                                    where node.Attribute("Query").Value.Equals(trackName, StringComparison.OrdinalIgnoreCase)
                                    select node;

                    if (trackNode.Any())
                    {
                        track = SpotifyService.Deserialize<SearchTrack>(HttpUtility.HtmlDecode(trackNode.First().Value));
                        status.Track = new TrackEx(track);
                        this.cachedSearchTracks[key] = track;
                        return;
                    }
                }

                status.Tracks = this.search.Value.SearchTracks(trackName);
                var trackQuery = status.Tracks.TrackList.Where(t => t.Artist.Href == status.ArtistHref && t.Name.Equals(trackName, StringComparison.OrdinalIgnoreCase));

                if (!trackQuery.Any())
                {
                    status.Status = FindNewTracksStatus.UnknownTrack;
                }
                else
                {
                    track = trackQuery.First();
                }

                if (track != null)
                {
                    status.Track = new TrackEx(track);
                    this.cachedSearchTracks[key] = track;

                    XElement trackNode = new XElement(
                        "Track",
                        new XAttribute("Query", trackName),
                        HttpUtility.HtmlEncode(SpotifyService.Serialize(track)));

                    if (File.Exists(path))
                    {
                        doc.Root.Add(trackNode);
                    }
                    else
                    {
                        doc = new XDocument(new XElement("Tracks", trackNode));
                    }

                    doc.Save(path);
                }
            }
        }

        /// <summary>
        /// Clears the current status
        /// </summary>
        private void ClearStatus()
        {
            this.SetStatus(string.Empty);
        }

        /// <summary>
        /// Sets the status to busy
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusBusy(string message)
        {
            this.SetStatus(message);
            this.SetBusyState(true);
        }

        /// <summary>
        /// Sets the status after an error
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusError(string message)
        {
            this.SetStatus(message, Color.Red);
            this.SetBusyState(false);
        }

        /// <summary>
        /// Sets the status after a successful event
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusSuccess(string message)
        {
            this.SetStatus(message);
            this.SetBusyState(false);
        }

        /// <summary>
        /// Sets the status
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatus(string message)
        {
            this.SetStatus(message, Color.FromArgb(148, 149, 153));
        }

        /// <summary>
        /// Sets the status
        /// </summary>
        /// <param name="message">Message to set</param>
        /// <param name="color">Message color to use</param>
        private void SetStatus(string message, Color color)
        {
            labelStatus.Text = message;
            labelStatus.ForeColor = color;
        }

        /// <summary>
        /// Sets busy state
        /// </summary>
        /// <param name="busy">True to use wait cursor</param>
        private void SetBusyState(bool busy)
        {
            Cursor.Current = busy ? Cursors.WaitCursor : Cursors.Default;
            this.Cursor = busy ? Cursors.WaitCursor : Cursors.Default;
            dataGridViewTracks.Cursor = busy ? Cursors.WaitCursor : Cursors.Default; // hack?
            this.UseWaitCursor = busy;
            Application.UseWaitCursor = busy;
        }

        /// <summary>
        /// Saves the artist cache
        /// </summary>
        private void SaveArtistCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.cachedArtistHrefs.Select(kvp => string.Format("{0}|||{1}", kvp.Key, kvp.Value)).ToArray());
            Properties.Settings.Default.CachedArtistHrefs = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Saves the misspelled artist cache
        /// </summary>
        private void SaveMisspelledArtistCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.misspelledArtists.Select(kvp => string.Format("{0}|||{1}", kvp.Key, kvp.Value)).ToArray());
            Properties.Settings.Default.CachedMisspelledArtists = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Saves the misspelled track cache
        /// </summary>
        private void SaveMisspelledTrackCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.misspelledTracks.Select(kvp => string.Format("{0}|||{1}", kvp.Key, kvp.Value)).ToArray());
            Properties.Settings.Default.CachedMisspelledTracks = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Reads the artist href cache
        /// </summary>
        private void ReadArtistCache()
        {
            foreach (string cachedArtistHrefLine in Properties.Settings.Default.CachedArtistHrefs)
            {
                string[] split = cachedArtistHrefLine.Split(new string[] { "|||" }, StringSplitOptions.None);
                this.cachedArtistHrefs[split[0]] = split[1];
            }
        }

        /// <summary>
        /// Reads the cached list of misspelled artists
        /// </summary>
        private void ReadMisspelledArtistCache()
        {
            foreach (string artist in Properties.Settings.Default.CachedMisspelledArtists)
            {
                string[] split = artist.Split(new string[] { "|||" }, StringSplitOptions.None);
                this.misspelledArtists[split[0]] = split[1];
            }
        }

        /// <summary>
        /// Reads the cached list of misspelled tracks
        /// </summary>
        private void ReadMisspelledTrackCache()
        {
            foreach (string track in Properties.Settings.Default.CachedMisspelledTracks)
            {
                string[] split = track.Split(new string[] { "|||" }, StringSplitOptions.None);
                this.misspelledTracks[split[0]] = split[1];
            }
        }

        /// <summary>
        /// Reads the track cache
        /// </summary>
        private void ReadCachedTracks()
        {
            foreach (string cachedTrackUrlLine in Properties.Settings.Default.CachedSearchTracks)
            {
                this.cachedSearchTracks.Add(cachedTrackUrlLine, null);
            }
        }

        /// <summary>
        /// Saves the track cache
        /// </summary>
        private void SaveSearchTrackCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.cachedSearchTracks.Select(kvp => kvp.Key).ToArray());
            Properties.Settings.Default.CachedSearchTracks = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// SpotConForm FormClosed event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_FormClosed(object sender, FormClosedEventArgs e)
        {
            if (this.listener != null)
            {
                this.listener.Close();
            }

            foreach (Socket worker in this.workers.Values)
            {
                if (worker != null)
                {
                    worker.Close();
                }
            }

            foreach (var item in this.hostData.Values)
            {
                if (item != null && item.Socket != null)
                {
                    item.Socket.Close();
                }
            }
        }

        /// <summary>
        /// toolStripButtonNext Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripButtonNext_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Next");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        private void SendToServer(string command)
        {
            this.SendToServer(command, this.selectedHost, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="server">Destination server</param>
        private void SendToServer(string command, string server)
        {
            this.SendToServer(command, server, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="server">Destination server</param>
        /// <param name="client">Client name</param>
        private void SendToServer(string command, string server, string client)
        {
            try
            {
                if (this.hostData.ContainsKey(server) && this.hostData[server].Socket != null && this.hostData[server].Socket.Connected)
                {
                    lock (this.sendLock)
                    {
                        byte[] bytes = Encoding.ASCII.GetBytes(client + "|" + command);
                        this.hostData[server].Socket.Send(bytes);
                    }
                }
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        private void SendToClient(string command)
        {
            this.SendToClient(command, this.selectedHost, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="client">Destination client</param>
        private void SendToClient(string command, string client)
        {
            this.SendToClient(command, client, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="client">Destination client</param>
        /// <param name="server">Server name</param>
        private void SendToClient(string command, string client, string server)
        {
            try
            {
                if (this.workers.ContainsKey(client) && this.workers[client].Connected)
                {
                    lock (this.sendLock)
                    {
                        byte[] bytes = Encoding.ASCII.GetBytes(server + "|" + command);
                        this.workers[client].Send(bytes);
                    }
                }
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// dataGridViewComputers CellClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_CellClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.ColumnIndex == (int)HostColumns.Checkbox)
            {
                bool isChecked = (bool)dataGridViewComputers[(int)HostColumns.Checkbox, e.RowIndex].Tag;
                this.dataGridViewComputers[e.ColumnIndex, e.RowIndex].Tag = !isChecked;

                if (isChecked)
                {
                    dataGridViewComputers[e.ColumnIndex, e.RowIndex].Value = Properties.Resources.Checkbox;
                }
                else
                {
                    dataGridViewComputers[e.ColumnIndex, e.RowIndex].Value = Properties.Resources.CheckboxChecked;
                }
            }
        }

        /// <summary>
        /// dataGridViewComputers CellValueChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_CellValueChanged(object sender, DataGridViewCellEventArgs e)
        {
            if (e.ColumnIndex != (int)HostColumns.Checkbox || e.RowIndex < 0)
            {
                return;
            }

            bool isChecked = (bool)dataGridViewComputers[e.ColumnIndex, e.RowIndex].Tag;
            string host = dataGridViewComputers[(int)HostColumns.Name, e.RowIndex].Value.ToString();

            if (!isChecked)
            {
                if (this.hostData.ContainsKey(host) && this.hostData[host] != null && this.hostData[host].Socket != null && this.hostData[host].Socket.Connected)
                {
                    this.hostData[host].Timer.Stop();
                    this.hostData[host].Socket.Close();
                    this.hostData[host].ConnectionStatus = ClientConnectStatus.Disconnected;
                    dataGridViewComputers[(int)HostColumns.ConnectionStatus, e.RowIndex].Value = this.hostImages.Images[(int)ClientConnectStatus.Disconnected];
                    this.SetStatus(string.Format(Properties.Resources.DisconnectedFrom, host));
                }
            }
            else
            {
                this.ConnectToServer(e.ColumnIndex, e.RowIndex, host);
            }
        }

        /// <summary>
        /// Connects to the server
        /// </summary>
        /// <param name="colIndex">Column index of host data grid</param>
        /// <param name="rowIndex">Row index of host data grid</param>
        /// <param name="server">Server to which to connect</param>
        private void ConnectToServer(int colIndex, int rowIndex, string server)
        {
            dataGridViewComputers.Enabled = false;
            BackgroundWorker bw = new BackgroundWorker() { WorkerReportsProgress = true };
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (!this.hostData.ContainsKey(server) || this.hostData[server] == null)
                {
                    bwArgs.Result = false;
                }
                else
                {
                    try
                    {
                        Socket socket = this.hostData[server].Socket != null &&
                                        this.hostData[server].Socket.Connected ? this.hostData[server].Socket : new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                        IPEndPoint remoteEndPoint = new IPEndPoint(this.hostData[server].IPAddress, Port);
                        IAsyncResult result = socket.BeginConnect(remoteEP: remoteEndPoint, callback: null, state: null);

                        if (server != this.currentHost)
                        {
                            bw.ReportProgress(0, string.Format(Properties.Resources.ConnectingToClient, server));
                        }

                        bool success = result.AsyncWaitHandle.WaitOne(millisecondsTimeout: 3000, exitContext: true);
                        if (success)
                        {
                            this.hostData[server].Socket = socket;
                            this.hostData[server].ConnectionStatus = socket.Connected ? ClientConnectStatus.Connected : ClientConnectStatus.ConnectionFailure;

                            if (socket.Connected)
                            {
                                this.SendToServer("|Connected");
                            }
                        }
                        else
                        {
                            socket.Close();
                            this.hostData[server].ConnectionStatus = ClientConnectStatus.ConnectionFailure;
                        }

                        bwArgs.Result = success;
                    }
                    catch (Exception ex)
                    {
                        bwArgs.Result = ex;
                    }
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                this.SetStatusBusy(bwArgs.UserState as string);
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                dataGridViewComputers.Enabled = true;

                if (bwArgs.Result is Exception)
                {
                    Exception ex = bwArgs.Result as Exception;
                    this.SetStatusError(ex.Message);
                }
                else if (bwArgs.Result is bool)
                {
                    bool success = (bool)bwArgs.Result;
                    ClientConnectStatus status = this.hostData[server] == null ? ClientConnectStatus.ConnectionFailure : this.hostData[server].ConnectionStatus;
                    dataGridViewComputers[(int)HostColumns.ConnectionStatus, rowIndex].Value = hostImages.Images[(int)status];
                    switch (status)
                    {
                        case ClientConnectStatus.Connected:
                            if (server != this.currentHost)
                            {
                                this.SetStatusSuccess(string.Format(Properties.Resources.ConnectingToClientSuccess, server));
                            }

                            dataGridViewComputers.Rows[rowIndex].Selected = true;

                            Timer timer = null;
                            if (this.hostData[server].Timer == null)
                            {
                                timer = new Timer() { Interval = this.defaultWaitTime, Enabled = true };
                                timer.Tick += (sender, e) =>
                                {
                                    BackgroundWorker bw2 = new BackgroundWorker();
                                    bw2.DoWork += (bw2Sender, bw2Args) =>
                                    {
                                        this.SendToServer("|GetStatusFromServer", server);
                                    };

                                    bw2.RunWorkerAsync();
                                };

                                this.hostData[server].Timer = timer;
                            }
                            else
                            {
                                timer = this.hostData[server].Timer;
                            }

                            foreach (var ip in this.hostData.Values.Where(i => i != null && i.Timer != null && i.Timer.Enabled))
                            {
                                ip.Timer.Stop();
                            }

                            timer.Start();
                            break;

                        case ClientConnectStatus.ConnectionFailure:
                            this.SetStatusError(string.Format(success ? Properties.Resources.ConnectingToClientUnknown : Properties.Resources.ConnectingToClientError, server));
                            dataGridViewComputers[colIndex, rowIndex].Value = Properties.Resources.Checkbox;
                            dataGridViewComputers[colIndex, rowIndex].Tag = false;
                            break;

                        case ClientConnectStatus.Disconnected:
                            this.ClearStatus();
                            break;
                    }

                    if (success && this.hostData[server].Socket.Connected)
                    {
                        this.WaitForDataClient(this.hostData[server].Socket);
                    }
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// dataGridViewComputers SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_SelectionChanged(object sender, EventArgs e)
        {
            if (dataGridViewComputers.SelectedRows.Count == 0)
            {
                return;
            }

            this.selectedHost = dataGridViewComputers.SelectedRows[0].Cells[(int)HostColumns.Name].Value.ToString();

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (this.hostData[this.selectedHost] == null)
                {
                    this.hostData[this.selectedHost] = new HostData() { IPAddress = Dns.GetHostAddresses(this.selectedHost).FirstOrDefault(i => i.AddressFamily == AddressFamily.InterNetwork) };
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                int selectedRowIndex = dataGridViewComputers.SelectedRows[0].Index;
                for (int i = 0; i < dataGridViewComputers.Rows.Count; i++)
                {
                    DataGridViewCellStyle style = dataGridViewComputers.Rows[i].InheritedStyle;
                    dataGridViewComputers.Rows[i].DefaultCellStyle = style;
                }

                foreach (var ip in this.hostData.Values.Where(i => i != null && i.Timer != null && i.Timer.Enabled))
                {
                    ip.Timer.Stop();
                }

                if (this.hostData[this.selectedHost] != null && this.hostData[this.selectedHost].Timer != null)
                {
                    this.hostData[this.selectedHost].Timer.Start();
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// dataGridViewComputers CurrentCellDirtyStateChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_CurrentCellDirtyStateChanged(object sender, EventArgs e)
        {
            if (dataGridViewComputers.IsCurrentCellDirty)
            {
                dataGridViewComputers.CommitEdit(DataGridViewDataErrorContexts.Commit);
            }
        }

        /// <summary>
        /// Updates the status
        /// </summary>
        /// <param name="status">Status to update</param>
        /// <returns>True if success</returns>
        private bool UpdateStatus(Responses.Status status)
        {
            if (status == null || status.OpenGraphState == null || status.OpenGraphState.PrivateSession)
            {
                this.SetStatusError(Properties.Resources.PrivateSessionError);
                return false;
            }

            if (status.Error != null)
            {
                this.SetStatusError(string.Format(Properties.Resources.StatusError, status.Error.Type));
                return false;
            }

            if (status.Track == null)
            {
                this.SetStatusError(string.Format(Properties.Resources.StatusError, string.Empty));
                return false;
            }

            if (this.linkLabelArtist.Text != status.Track.ArtistResource.Name)
            {
                this.linkLabelArtist.Text = status.Track.ArtistResource.Name;
                this.linkLabelArtist.Tag = status.Track.ArtistResource.Uri;
                this.linkLabelArtist.Enabled = true;
            }

            if (this.linkLabelTrack.Text != status.Track.TrackResource.Name)
            {
                this.linkLabelTrack.Text = status.Track.TrackResource.Name;
                this.linkLabelTrack.Tag = status.Track.TrackResource.Uri;
                this.linkLabelTrack.Enabled = true;
            }

            if (!panelPlayPause.Capture)
            {
                if (status.Playing)
                {
                    this.panelPlayPause.BackgroundImage = Properties.Resources.Pause;
                }
                else
                {
                    this.panelPlayPause.BackgroundImage = Properties.Resources.Play;
                }

                if (status.IsPlayEnabled)
                {
                    this.panelPlayPause.Enabled = true;
                }
                else
                {
                    this.panelPlayPause.Enabled = false;
                    this.panelPlayPause.BackgroundImage = Properties.Resources.PlayDisabled;
                }
            }

            if (!this.panelPrevious.Capture)
            {
                if (status.IsPrevEnabled)
                {
                    this.panelPrevious.Enabled = true;
                    this.panelPrevious.BackgroundImage = Properties.Resources.Previous;
                }
                else
                {
                    this.panelPrevious.Enabled = false;
                    this.panelPrevious.BackgroundImage = Properties.Resources.PreviousDisabled;
                }
            }

            if (!this.panelNext.Capture)
            {
                this.panelNext.Enabled = true;
            }

            if (!this.panelVolumeKnob.Capture)
            {
                this.panelVolumeKnob.Left = this.panelVolumeLeftEnd.Left + (int)((this.panelVolumeRightEnd.Right - this.panelVolumeLeftEnd.Left - (this.panelVolumeKnob.Width / 2)) * status.Volume / 1.0);
                this.ResizeVolumePanels();
            }

            if (status.Playing || this.panelTrackKnob.Tag == null)
            {
                string position = TimeSpan.FromSeconds(Math.Ceiling(status.PlayingPosition)).ToString(@"m\:ss");
                string end = TimeSpan.FromSeconds((double)status.Track.Length).ToString(@"m\:ss");
                this.labelTrackTime.Text = position;
                this.labelTrackLength.Text = end;

                this.MoveTrackKnob(status);
            }

            this.panelShuffle.BackgroundImage = status.Shuffle ? Properties.Resources.ShuffleGreen : Properties.Resources.Shuffle;
            this.panelRepeat.BackgroundImage = status.Repeat ? Properties.Resources.RepeatGreen : Properties.Resources.Repeat;

            return true;
        }

        /// <summary>
        /// Positions the track nob based on the current play position
        /// </summary>
        /// <param name="status">Current play status</param>
        private void MoveTrackKnob(Responses.Status status)
        {
            int trackPosWidth = this.panelTrackRightEnd.Right - this.panelTrackLeftEnd.Left;
            this.panelTrackKnob.Left = this.panelTrackLeftEnd.Left + (int)(trackPosWidth * (status.PlayingPosition / status.Track.Length));
            this.panelTrackKnob.Tag = status.PlayingPosition;

            this.panelTrackLeft.Width = this.panelTrackKnob.Left - this.panelTrackLeft.Left + (this.panelTrackKnob.Width / 2);
            this.panelTrackRight.Left = this.panelTrackLeft.Right;
            this.panelTrackRight.Width = this.labelTrackLength.Left - this.panelTrackLeft.Right - 1;
        }

        /// <summary>
        /// Adds an action to the history queue
        /// </summary>
        /// <param name="action">Action to add</param>
        private void AddHistoryAction(Action action)
        {
            this.history.RemoveRange(this.historyIndex + 1, this.history.Count - this.historyIndex - 1);
            this.history.Add(action);
            this.historyIndex++;

            if (this.history.Count > 1)
            {
                this.panelBack.Tag = true;
                this.panelBack.BackgroundImage = Properties.Resources.Back;
            }

            if (this.historyIndex == this.history.Count - 1)
            {
                this.panelForward.Tag = false;
                this.panelForward.BackgroundImage = Properties.Resources.ForwardDisabled;
            }
        }

        /// <summary>
        /// Lookups the given album
        /// </summary>
        /// <param name="query">Album href</param>
        /// <param name="selectedTrackHref">Href of track to select</param>
        /// <param name="friendlyName">The query to display in the status bar</param>
        /// <param name="fromHistory">Indicates whether the method is being invoked from the history</param>
        private void LookupAlbum(string query, string selectedTrackHref, string friendlyName, bool fromHistory = false)
        {
            if (string.IsNullOrEmpty(query))
            {
                return;
            }

            if (!fromHistory)
            {
                string queryCopy = string.Copy(query);
                string selectedTrackHrefCopy = string.Copy(selectedTrackHref);
                this.AddHistoryAction(() => this.LookupAlbum(queryCopy, selectedTrackHrefCopy, friendlyName, fromHistory: true));
            }

            this.SetStatus(string.Format(Properties.Resources.Searching, friendlyName));
            this.dataGridViewTracks.IgnoreSelectionChangesAndClearRows();
            this.dataGridViewTracks.IgnoreSelectionChangesAndClearRows();
            this.dataGridViewTracks.IgnoreSelectionChangesAndClearRows();
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                query = query.Split(':')[2];

                Album album = null;
                string albumPath = Path.Combine(Application.UserAppDataPath, "Lookup", "Albums", query + ".xml");
                if (this.cachedLookupAlbums.ContainsKey(query))
                {
                    album = this.cachedLookupAlbums[query];
                }
                else if (File.Exists(albumPath))
                {
                    album = SpotifyService.Deserialize<Album>(File.ReadAllText(albumPath));
                }

                if (album == null || album.Tracks.Count == 0)
                {
                    album = lookup.Value.LookupAlbum(query, LookupService.AlbumExtras.TrackDetail);
                    SpotifyService.Serialize(album, albumPath);
                }

                album.Href = "spotify:album:" + query;

                this.trackDataSet = (new AlbumEx(album)).Tracks;
                this.trackDataSetFiltered = this.GroupAndSortTracks(this.trackDataSet);
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.SetStatus(string.Format(Properties.Resources.DisplayResults, this.trackDataSetFiltered.Count, this.trackDataSetFiltered.Count == 1 ? string.Empty : "s", friendlyName));
                this.PopulateTracks(selectedTrackHref);
                this.PopulateArtistFilter();
                this.PopulateAlbumFilter();
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Searches the Spotify database
        /// </summary>
        /// <param name="searchType">Type of search. Used in filtering the results</param>
        /// <param name="fromHistory">Indicates whether the method is being invoked from the history</param>
        private void Search(SearchType? searchType = null, bool fromHistory = false)
        {
            Tuple<string, int?> input = this.searchQueue.Dequeue();
            string query = input.Item1;
            int? page = input.Item2;

            if (!page.HasValue)
            {
                // Reset the page counter when a fresh search comes in
                this.trackScrollBar.Tag = null;
            }

            Action action = null;
            if (query.StartsWith("spotify:"))
            {
                action = new Action(() => this.SendToServer(query + "|Play"));
            }
            else if (query.StartsWith("http://open.spotify.com"))
            {
                action = new Action(() => this.SendToServer(query + "|Play"));
            }
            else
            {
                if (!fromHistory && !page.HasValue)
                {
                    this.AddHistoryAction(() =>
                    {
                        this.searchQueue.Enqueue(new Tuple<string, int?>(query, null));
                        this.Search(searchType, fromHistory: true);
                    });
                }

                this.SetStatusBusy(string.Format(page.HasValue ? Properties.Resources.SearchingPage : Properties.Resources.Searching, query, page));
            }

            BackgroundWorker bw = new BackgroundWorker() { WorkerReportsProgress = true };
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (action != null)
                {
                    action.Invoke();
                }
                else
                {
                    List<SearchTrack> tracks = search.Value.SearchTracks(query, page).TrackList;
                    if (searchType.HasValue)
                    {
                        switch (searchType.Value)
                        {
                            case SearchType.Album:
                                tracks = tracks.Where(t => t.Album.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                            case SearchType.Artist:
                                tracks = tracks.Where(t => t.Artist.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                            case SearchType.Track:
                                tracks = tracks.Where(t => t.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                        }
                    }

                    if (!page.HasValue)
                    {
                        this.trackDataSet.Clear();
                    }

                    this.trackDataSet.AddRange(tracks.Select(t => new TrackEx(t)).ToList());
                    this.trackDataSetFiltered = this.GroupAndSortTracks(this.trackDataSet);
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                Tuple<int, int> status = bwArgs.UserState as Tuple<int, int>;
                this.SetProgressBar(status.Item1, status.Item2);
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.dataGridViewTracks.Tag = query;
                this.PopulateTracks(append: page.HasValue && page.Value > 1);
                this.PopulateArtistFilter();
                this.PopulateAlbumFilter();

                if (!this.searchQueue.Any())
                {
                    this.SetBusyState(false);
                    this.SetStatus(string.Format(Properties.Resources.DisplayResults, this.trackDataSet.Count, this.trackDataSet.Count == 1 ? string.Empty : "s", query));
                }
                else
                {
                    this.Search();
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Groups and sorts the track information
        /// </summary>
        /// <param name="tracks">Tracks to group and sort</param>
        /// <returns>Grouped and filtered list of tracks</returns>
        private List<TrackEx> GroupAndSortTracks(List<TrackEx> tracks)
        {
            List<TrackEx> filtered = new List<TrackEx>();
            //// 1. Sort the tracks by album release date (descending)
            //// 2. Sort the tracks by track number (increasing)
            //// 3. Group the tracks by album
            //// 4. Put the albums with less than five tracks at the bottom of the list
            tracks = tracks.OrderByDescending(t => t.Album.Released).ThenBy(t => t.TrackNumber).ToList();

            var groupedTracks = from t in tracks
                                group t by t.Album.Href into albumGroup
                                group albumGroup by albumGroup.Count() > 4 into bigAlbumGroup
                                orderby bigAlbumGroup.Key ? 1 : 0
                                select bigAlbumGroup;

            foreach (var bigAlbumGroup in groupedTracks)
            {
                foreach (var album in bigAlbumGroup)
                {
                    var discQuery = from track in album
                                    group track by track.DiscNumber into discGroup
                                    orderby discGroup.Key ascending
                                    select discGroup;

                    foreach (var disc in discQuery)
                    {
                        filtered.AddRange(disc.ToList());
                    }
                }
            }

            return filtered;
        }

        /// <summary>
        /// Populates the track information
        /// </summary>
        /// <param name="selectedTrackHref">The hypertext reference of the selected track, null if no selection exists</param>
        /// <param name="append">True to append the new tracks -- used when scrolling to the bottom and initiating a page 'n' search</param>
        private void PopulateTracks(string selectedTrackHref = null, bool append = false)
        {
            if (!append)
            {
                this.dataGridViewTracks.Rows.Clear();
            }

            int rows = this.dataGridViewTracks.Rows.Count;

            int numDiscs = 0;
            this.trackDataSetFiltered.ForEach(t =>
            {
                DataGridViewRow row = new DataGridViewRow();
                row.CreateCells(this.dataGridViewTracks, t.DiscNumber == numDiscs ? string.Empty : t.DiscNumber.ToString(), t.TrackNumber, t.Name, t.Artist.Name, TimeSpan.FromSeconds(t.Length).ToString(@"m\:ss"), this.GetPopularityImage(t.Popularity), t.Album.Name);
                row.Cells[(int)TrackColumns.Popularity].Tag = t.Popularity;
                row.Cells[(int)TrackColumns.Time].Tag = t.Length;
                row.Tag = t;
                row.Height = 42;
                numDiscs = Math.Max(numDiscs, t.DiscNumber);

                int index = this.dataGridViewTracks.Rows.Add(row);
                row.Selected = t.Href == selectedTrackHref;
            });

            this.dataGridViewTracks.Columns[(int)TrackColumns.Disc].Visible = numDiscs > 1;
        }

        /// <summary>
        /// Populates artist filter
        /// </summary>
        /// <param name="track">Track to add</param>
        private void PopulateArtistFilter(TrackEx track)
        {
            Dictionary<string, TrackEx> distinctArtists = this.dataGridViewArtists.Tag as Dictionary<string, TrackEx>;

            if (distinctArtists == null)
            {
                distinctArtists = new Dictionary<string, TrackEx>();
            }

            if (!distinctArtists.ContainsKey(track.Artist.Href))
            {
                distinctArtists.Add(track.Artist.Href, track);
                if (this.dataGridViewArtists.Rows.Count == 0)
                {
                    this.dataGridViewArtists.Rows.Add(string.Format("All ({0} artist{1})", distinctArtists.Count(), distinctArtists.Count() == 1 ? string.Empty : "s"));
                }
                else
                {
                    this.dataGridViewArtists[0, 0].Value = string.Format("All ({0} artist{1})", distinctArtists.Count(), distinctArtists.Count() == 1 ? string.Empty : "s");
                }

                DataGridViewRow newRow = new DataGridViewRow();
                newRow.CreateCells(this.dataGridViewArtists, track.Artist.Name);
                newRow.Tag = track;

                int index = this.dataGridViewArtists.Rows.Count;
                foreach (DataGridViewRow row in this.dataGridViewArtists.Rows)
                {
                    if (row.Index == 0)
                    {
                        continue;
                    }

                    string artistName = row.Cells[0].Value.ToString();
                    if (string.Compare(track.Artist.Name, artistName) < 0)
                    {
                        index = row.Index;
                        break;
                    }
                }

                this.dataGridViewArtists.Rows.Insert(index, newRow);
                this.dataGridViewArtists.Tag = distinctArtists;
            }
        }

        /// <summary>
        /// Populates the artist filters
        /// </summary>
        private void PopulateArtistFilter()
        {
            // Don't trigger any selection change events
            this.dataGridViewArtists.SelectionChanged -= this.dataGridViewArtists_SelectionChanged;

            this.dataGridViewArtists.Rows.Clear();

            var distinctArtists = from t in this.trackDataSetFiltered
                                  orderby t.Artist.Name
                                  group t by t.Artist.Href into T
                                  select T;

            Dictionary<string, TrackEx> distinctArtistTracks = new Dictionary<string, TrackEx>();
            if (distinctArtists.Any())
            {
                this.dataGridViewArtists.Rows.Add(string.Format("All ({0} artist{1})", distinctArtists.Count(), distinctArtists.Count() == 1 ? string.Empty : "s"));
                foreach (var distinctArtist in distinctArtists)
                {
                    TrackEx track = distinctArtist.First();
                    distinctArtistTracks.Add(track.Artist.Href, track);

                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewArtists, track.Artist.Name);
                    row.Tag = track;
                    this.dataGridViewArtists.Rows.Add(row);
                }

                this.dataGridViewArtists.SelectionChanged += this.dataGridViewArtists_SelectionChanged;
            }

            this.dataGridViewArtists.Tag = distinctArtistTracks;
        }

        /// <summary>
        /// Populates the album filter
        /// </summary>
        /// <param name="track">Track to add</param>
        private void PopulateAlbumFilter(TrackEx track)
        {
            Dictionary<string, AlbumEx> distinctAlbums = this.dataGridViewAlbums.Tag as Dictionary<string, AlbumEx>;

            if (distinctAlbums == null)
            {
                distinctAlbums = new Dictionary<string, AlbumEx>();
            }

            if (distinctAlbums.ContainsKey(track.Album.Href))
            {
                foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
                {
                    AlbumEx album = row.Tag as AlbumEx;
                    if (album != null && album.Href.Equals(track.Album.Href))
                    {
                        int numTracks = int.Parse(row.Cells[(int)AlbumColumns.NumberOfTracks].Value.ToString());
                        row.Cells[(int)AlbumColumns.NumberOfTracks].Value = numTracks + 1;
                        break;
                    }
                }
            }
            else
            {
                AlbumEx album = new AlbumEx(track);
                distinctAlbums.Add(track.Album.Href, album);

                if (this.dataGridViewAlbums.Rows.Count == 0)
                {
                    this.dataGridViewAlbums.Rows.Add(string.Format("All ({0} album{1})", distinctAlbums.Count(), distinctAlbums.Count() == 1 ? string.Empty : "s"));
                }
                else
                {
                    this.dataGridViewAlbums[(int)AlbumColumns.Name, 0].Value = string.Format("All ({0} album{1})", distinctAlbums.Count(), distinctAlbums.Count() == 1 ? string.Empty : "s");
                }

                DataGridViewRow newRow = new DataGridViewRow();
                object released = track.Album.Released;
                if (track.Album.Released == 0)
                {
                    released = null;
                }

                newRow.CreateCells(this.dataGridViewAlbums, track.Album.Name, album.Tracks.Count, released);
                newRow.Tag = album;

                int index = 1;
                foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
                {
                    if (row.Index == 0)
                    {
                        continue;
                    }

                    index = row.Index;
                    string albumName = row.Cells[(int)AlbumColumns.Name].Value.ToString();
                    if (string.Compare(track.Album.Name, albumName) < 0)
                    {
                        break;
                    }
                }

                this.dataGridViewAlbums.Rows.Insert(index, newRow);
            }

            this.dataGridViewAlbums.Tag = distinctAlbums;
        }

        /// <summary>
        /// Populates the artist filters
        /// </summary>
        /// <param name="selectedArtistHrefs">The hypertext reference of the selected artist, null if no selection exists</param>
        private void PopulateAlbumFilter(List<string> selectedArtistHrefs = null)
        {
            if (selectedArtistHrefs == null || !selectedArtistHrefs.Any())
            {
                // Don't trigger any selection change events
                this.dataGridViewAlbums.SelectionChanged -= this.dataGridViewAlbums_SelectionChanged;

                this.dataGridViewAlbums.Rows.Clear();

                var distinctAlbums = from t in this.trackDataSet
                                     group t by t.Album.Href into g
                                     orderby g.First().Album.Released descending
                                     group g by g.Count() > 4 into g2
                                     let orderValue = g2.Key ? 1 : 0
                                     select g2;

                Dictionary<string, AlbumEx> distinctAlbumList = new Dictionary<string, AlbumEx>();
                if (distinctAlbums.Count() > 0)
                {
                    int totalAlbums = distinctAlbums.Sum(a => a.Count());
                    this.dataGridViewAlbums.Rows.Add(string.Format("All ({0} album{1})", totalAlbums, totalAlbums == 1 ? string.Empty : "s"));

                    foreach (var group in distinctAlbums)
                    {
                        foreach (var distinctAlbum in group)
                        {
                            AlbumEx album = new AlbumEx(distinctAlbum.ToList());
                            distinctAlbumList.Add(album.Href, album);

                            TrackEx track = distinctAlbum.First();
                            DataGridViewRow row = new DataGridViewRow();
                            row.CreateCells(this.dataGridViewAlbums, track.Album.Name, album.Tracks.Count, track.Album.Released);
                            row.Tag = album;
                            this.dataGridViewAlbums.Rows.Add(row);
                        }
                    }

                    this.dataGridViewAlbums.SelectionChanged += this.dataGridViewAlbums_SelectionChanged;
                }

                this.dataGridViewAlbums.Tag = distinctAlbumList;
            }
            else
            {
                int totalAlbums = 0;
                foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
                {
                    if (row.Index == 0)
                    {
                        continue;
                    }

                    List<string> albumArtistHrefs = (row.Tag as AlbumEx).Tracks.Select(t => t.Artist.Href).Distinct().ToList();
                    int numTracks = (row.Tag as AlbumEx).Tracks.Count(t => selectedArtistHrefs.Contains(t.Artist.Href));
                    bool show = numTracks > 0;
                    row.Visible = show;
                    if (show)
                    {
                        totalAlbums++;
                        row.Cells[(int)AlbumColumns.NumberOfTracks].Value = numTracks;
                    }
                }

                this.dataGridViewAlbums[(int)AlbumColumns.Name, 0].Value = string.Format("All ({0} album{1})", totalAlbums, totalAlbums == 1 ? string.Empty : "s");
            }
        }

        /// <summary>
        /// Gets the popularity image
        /// </summary>
        /// <param name="popularity">Track popularity value</param>
        /// <returns>Desired popularity image</returns>
        private Image GetPopularityImage(double? popularity)
        {
            int numImages = this.popImages.Images.Count - 1;
            int index = popularity.HasValue ? (int)((double)numImages * popularity) : 0;
            return this.popImages.Images[index];
        }

        /// <summary>
        /// dataGridViewTracks CellDoubleClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex < 0)
            {
                return;
            }

            this.PlayTrackset(e.RowIndex);
        }

        /// <summary>
        /// Plays the set of tracks starting at the given index through the end of the search results
        /// </summary>
        /// <param name="startRowIndex">Starting row index</param>
        private void PlayTrackset(int startRowIndex)
        {
            List<string> tracks = new List<string>();
            for (int i = startRowIndex; i < this.dataGridViewTracks.Rows.Count; i++)
            {
                tracks.Add((this.dataGridViewTracks.Rows[i].Tag as TrackEx).Href.Replace("spotify:track:", string.Empty));
            }

            string trackset = "spotify:trackset:SpotCon:" + string.Join(",", tracks);
            this.SendToServer(trackset + "|Play");
        }

        /// <summary>
        /// pictureBox Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void pictureBox_Click(object sender, EventArgs e)
        {
            if (pictureBox.Image != null)
            {
                AlbumArtViewer arv = new AlbumArtViewer(this.currentStatus.Track.AlbumResource.ToString(), pictureBox.Image);
                arv.Show();
            }
        }

        /// <summary>
        /// linkLabelTrack LinkClicked event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelTrack_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            this.LookupAlbum(this.currentStatus.Track.AlbumResource.Uri, this.currentStatus.Track.TrackResource.Uri, this.currentStatus.Track.TrackResource.Name);
        }

        /// <summary>
        /// linkLabelArtist LinkClicked event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelArtist_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            this.queuedIndices.Clear();
            this.searchQueue.Enqueue(new Tuple<string, int?>(linkLabelArtist.Text, null));
            this.Search(SearchType.Artist);
        }

        /// <summary>
        /// dataGridViewTracks SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_SelectionChanged(object sender, EventArgs e)
        {
            if (dataGridViewTracks.SelectedRows.Count == 0)
            {
                return;
            }

            List<int> newSelectedTrackRowIndices = new List<int>();
            for (int i = 0; i < dataGridViewTracks.SelectedRows.Count; i++)
            {
                DataGridViewRow row = dataGridViewTracks.SelectedRows[i];
                DataGridViewImageCell pop = (DataGridViewImageCell)row.Cells[(int)TrackColumns.Popularity];
                pop.Value = this.GetPopularityImage((double)pop.Tag);

                newSelectedTrackRowIndices.Add(row.Index);
            }

            this.selectedTrackRowIndices.RemoveAll(x => newSelectedTrackRowIndices.Contains(x));
            foreach (int i in this.selectedTrackRowIndices)
            {
                if (i < dataGridViewTracks.Rows.Count)
                {
                    DataGridViewRow row = dataGridViewTracks.Rows[i];
                    DataGridViewImageCell pop = (DataGridViewImageCell)row.Cells[(int)TrackColumns.Popularity];
                    pop.Value = this.GetPopularityImage((double)pop.Tag);
                }
            }

            this.selectedTrackRowIndices = newSelectedTrackRowIndices;
        }

        /// <summary>
        /// dataGridViewTracks RowLeave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_RowLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                DataGridViewImageCell pop = (DataGridViewImageCell)dataGridViewTracks[(int)TrackColumns.Popularity, e.RowIndex];
                pop.Value = this.GetPopularityImage((double)pop.Tag);
            }
        }

        /// <summary>
        /// dataGridViewTracks CellContentClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                if (e.ColumnIndex == (int)TrackColumns.Artist)
                {
                    this.queuedIndices.Clear();
                    this.searchQueue.Enqueue(new Tuple<string, int?>(dataGridViewTracks[e.ColumnIndex, e.RowIndex].Value.ToString(), null));
                    this.Search(SearchType.Artist);
                }
                else if (e.ColumnIndex == (int)TrackColumns.Album)
                {
                    string uri = (this.dataGridViewTracks.Rows[e.RowIndex].Tag as TrackEx).Album.Href;
                    string name = this.dataGridViewTracks[(int)TrackColumns.Track, e.RowIndex].Value.ToString();
                    this.LookupAlbum(uri, (this.dataGridViewTracks.Rows[e.RowIndex].Tag as TrackEx).Href, name);
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks CellMouseEnter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellMouseEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0 && e.RowIndex < this.dataGridViewTracks.Rows.Count)
            {
                DataGridViewRow row = this.dataGridViewTracks.Rows[e.RowIndex];
                row.DefaultCellStyle.BackColor = Color.FromArgb(28, 28, 31);

                if (row.Selected)
                {
                    row.DefaultCellStyle.SelectionBackColor = Color.FromArgb(28, 28, 31);
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks CellMouseLeave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellMouseLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0 && e.RowIndex < this.dataGridViewTracks.Rows.Count)
            {
                DataGridViewRow row = this.dataGridViewTracks.Rows[e.RowIndex];
                row.DefaultCellStyle.BackColor = this.dataGridViewTracks.DefaultCellStyle.BackColor;

                if (row.Selected)
                {
                    row.DefaultCellStyle.SelectionBackColor = this.dataGridViewTracks.DefaultCellStyle.SelectionBackColor;
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks ColumnHeaderMouseClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            this.SortTracklist(e.ColumnIndex);
        }

        /// <summary>
        /// Sorts the track list
        /// </summary>
        /// <param name="column">Column to sort on</param>
        /// <param name="sortOrder">Order of the sort</param>
        private void SortTracklist(int column, SortOrder? sortOrder = null)
        {
            Type type = typeof(string);
            switch (column)
            {
                case (int)TrackColumns.Album:
                case (int)TrackColumns.Artist:
                case (int)TrackColumns.Track:
                    type = typeof(string);
                    break;
                case (int)TrackColumns.Popularity:
                case (int)TrackColumns.Time:
                    type = typeof(double);
                    break;
                case (int)TrackColumns.TrackNumber:
                    type = typeof(int);
                    break;
            }

            // Remove sort glyph from all other headers
            foreach (DataGridViewColumn col in dataGridViewTracks.Columns)
            {
                if (col.Index != column)
                {
                    col.HeaderCell.SortGlyphDirection = System.Windows.Forms.SortOrder.None;
                }
            }

            if (!sortOrder.HasValue)
            {
                sortOrder = dataGridViewTracks.Columns[column].HeaderCell.SortGlyphDirection;
                if ((column == (int)TrackColumns.TrackNumber && sortOrder == SortOrder.None) ||
                    sortOrder == System.Windows.Forms.SortOrder.Descending)
                {
                    sortOrder = System.Windows.Forms.SortOrder.Ascending;
                }
                else
                {
                    sortOrder = System.Windows.Forms.SortOrder.Descending;
                }
            }

            dataGridViewTracks.Sort(new DataGridViewRowComparer(column, sortOrder.Value, type));
            dataGridViewTracks.Columns[column].HeaderCell.SortGlyphDirection = sortOrder.Value;

            foreach (DataGridViewRow row in this.dataGridViewTracks.Rows)
            {
                if (row.Visible)
                {
                    row.Cells[(int)TrackColumns.Popularity].Style = new DataGridViewCellStyle(row.DefaultCellStyle) { Alignment = DataGridViewContentAlignment.MiddleCenter };
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks Scroll event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_Scroll(object sender, ScrollEventArgs e)
        {
            if (e.ScrollOrientation == ScrollOrientation.VerticalScroll)
            {
                if (!this.queuedIndices.Contains(this.trackScrollBar.Maximum) && this.trackScrollBar.Value > (double)this.trackScrollBar.Maximum * 0.9)
                {
                    string query = this.dataGridViewTracks.Tag as string;

                    if (!string.IsNullOrEmpty(query))
                    {
                        int page = 2;
                        if (this.trackScrollBar.Tag == null)
                        {
                            this.trackScrollBar.Tag = page;
                        }
                        else
                        {
                            page = (int)this.trackScrollBar.Tag;
                            this.trackScrollBar.Tag = ++page;
                        }

                        this.queuedIndices.Add(this.trackScrollBar.Maximum);
                        this.searchQueue.Enqueue(new Tuple<string, int?>(query, page));
                        this.Search();
                    }
                }
            }
        }

        /// <summary>
        /// linkLabelTrack MouseHover event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelTrack_MouseHover(object sender, EventArgs e)
        {
            this.tooltipTrack.Show(linkLabelTrack.Text, this.linkLabelTrack);
        }

        /// <summary>
        /// linkLabelArtist MouseHover event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelArtist_MouseHover(object sender, EventArgs e)
        {
            this.tooltipArtist.Show(linkLabelArtist.Text, this.linkLabelArtist);
        }

        /// <summary>
        /// panelPlayPause MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelPlayPause.Capture = true;
        }

        /// <summary>
        /// panelPlayPause MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelPlayPause.Capture = false;
            if (this.currentStatus.Playing)
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.Pause;
            }
            else
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.Play;
            }
        }

        /// <summary>
        /// panelPrevious MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelPrevious.Capture = true;
        }

        /// <summary>
        /// panelPrevious MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelPrevious.Capture = false;
        }

        /// <summary>
        /// panelNext MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelNext.Capture = true;
        }

        /// <summary>
        /// panelNext MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelNext.Capture = false;
        }

        /// <summary>
        /// panelPrevious Click
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Previous");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// panelPlayPause Click
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Pause");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// panelNext Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Next");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// textBoxSearch Enter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_Enter(object sender, EventArgs e)
        {
            if (this.textBoxSearch.Text == "Search")
            {
                this.textBoxSearch.Text = string.Empty;
                this.textBoxSearch.ForeColor = Color.FromKnownColor(KnownColor.WindowText);
            }
        }

        /// <summary>
        /// textBoxSearch Leave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_Leave(object sender, EventArgs e)
        {
            this.panelSearch.BackgroundImage = Properties.Resources.Search;
            if (string.IsNullOrEmpty(this.textBoxSearch.Text))
            {
                this.textBoxSearch.Text = "Search";
                this.textBoxSearch.ForeColor = (Color)this.textBoxSearch.Tag;
            }
        }

        /// <summary>
        /// textBoxSearch KeyDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                this.queuedIndices.Clear();
                this.searchQueue.Enqueue(new Tuple<string, int?>(textBoxSearch.Text, null));
                this.Search();
                e.SuppressKeyPress = true;
                this.ActiveControl = this.panelPlayPause;
            }
        }

        /// <summary>
        /// splitterMain SplitterMoved event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void splitterMain_SplitterMoved(object sender, SplitterEventArgs e)
        {
            this.linkLabelTrack.MaximumSize = new Size(splitterMain.Location.X, this.linkLabelTrack.Height);
            this.linkLabelArtist.MaximumSize = new Size(splitterMain.Location.X, this.linkLabelArtist.Height);
            panelPicture.Height = splitterMain.Location.X;
        }

        /// <summary>
        /// SpotConForm Resize event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_Resize(object sender, EventArgs e)
        {
            this.panelRepeat.Location = new Point(this.Width - 40, this.panelRepeat.Location.Y);
            this.panelShuffle.Location = new Point(this.panelRepeat.Location.X - 1, this.panelShuffle.Location.Y);
        }

        /// <summary>
        /// SpotConForm ResizeBegin event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_ResizeBegin(object sender, EventArgs e)
        {
            this.panelFilter.SuspendLayout();
            this.albumPercentage = (double)this.dataGridViewAlbums.Width / (double)this.dataGridViewTracks.Width;
        }

        /// <summary>
        /// SpotConForm ResizeEnd event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_ResizeEnd(object sender, EventArgs e)
        {
            this.panelFilter.ResumeLayout();
            this.dataGridViewAlbums.Width = (int)Math.Round(this.dataGridViewTracks.Width * this.albumPercentage);
        }

        /// <summary>
        /// SpotConForm SizeChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_SizeChanged(object sender, EventArgs e)
        {
            if (this.WindowState == FormWindowState.Maximized || (this.wasMaximized && this.WindowState == FormWindowState.Normal))
            {
                this.wasMaximized = !this.wasMaximized;
                this.dataGridViewAlbums.Width = (int)Math.Round(this.dataGridViewTracks.Width * this.albumPercentage);
                this.dataGridViewArtists.Visible = this.dataGridViewAlbums.Visible = true;
            }
        }

        /// <summary>
        /// splitterFilterRight SplitterMoved event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void splitterFilterRight_SplitterMoved(object sender, SplitterEventArgs e)
        {
            this.albumPercentage = (double)this.dataGridViewAlbums.Width / (double)this.dataGridViewTracks.Width;
        }

        /// <summary>
        /// pictureBox SizeChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void pictureBox_SizeChanged(object sender, EventArgs e)
        {
            this.MinimumSize = new Size(500, Math.Max(410, 410 + panelPicture.Height - 150));
        }

        /// <summary>
        /// panelVolumeKnob MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Tag = e.X;
            this.panelVolumeKnob.Capture = true;
            this.panelVolumeKnob.BackgroundImage = Properties.Resources.VolumeKnobClicked;
        }

        /// <summary>
        /// panelVolumeKnob MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Capture = false;
            this.panelVolumeKnob.BackgroundImage = Properties.Resources.VolumeKnob;
            this.ChangeVolume();
        }

        /// <summary>
        /// Changes the volume
        /// </summary>
        private void ChangeVolume()
        {
            double level = (double)((this.panelVolumeKnob.Left + (this.panelVolumeKnob.Width / 2)) - this.panelVolumeLeftEnd.Left) / (double)(this.panelVolumeRightEnd.Right - this.panelVolumeLeftEnd.Left);
            this.SendToServer(level + ":" + this.currentStatus.Volume + "|SetVolume");
        }

        /// <summary>
        /// panelVolumeKnob MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseMove(object sender, MouseEventArgs e)
        {
            if (this.panelVolumeKnob.Capture)
            {
                this.MoveVolumeKnob(e.X);
            }
        }

        /// <summary>
        /// Moves the volume knob to the given x-coordinate
        /// </summary>
        /// <param name="x">Coordinate to which to move the volume knob</param>
        private void MoveVolumeKnob(int x)
        {
            int halfKnob = this.panelVolumeKnob.Width / 2;
            panelVolumeKnob.Left = Math.Min(Math.Max(this.panelVolumeLeftEnd.Left - halfKnob, x + this.panelVolumeKnob.Left - halfKnob), this.panelVolumeRightEnd.Right - halfKnob);
            this.ResizeVolumePanels();
        }

        /// <summary>
        /// Resizes the volume panels based on the positions of the volume knob
        /// </summary>
        private void ResizeVolumePanels()
        {
            this.panelVolumeLeft.Width = panelVolumeKnob.Left - this.panelVolumeLeftEnd.Right;
            this.panelVolumeRight.Left = panelVolumeKnob.Right;
            this.panelVolumeRight.Width = this.panelVolumeRightEnd.Left - this.panelVolumeRight.Left;
        }

        /// <summary>
        /// panelVolume MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolume_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Tag = e.X;
            this.panelVolumeKnob.Capture = true;
            this.MoveVolumeKnob(e.X);
        }

        /// <summary>
        /// panelVolume MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolume_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Capture = false;
            this.ChangeVolume();
        }

        /// <summary>
        /// panelForward MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseMove(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                if (this.panelForward.Bounds.Contains(this.panelForward.Parent.PointToClient(Control.MousePosition)))
                {
                    this.panelForward.Capture = true;
                    this.panelForward.BackgroundImage = Properties.Resources.ForwardHover;
                }
                else
                {
                    this.panelForward.Capture = false;
                    this.panelForward.BackgroundImage = Properties.Resources.Forward;
                }
            }
        }

        /// <summary>
        /// panelBack MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseMove(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                if (panelBack.Bounds.Contains(panelBack.Parent.PointToClient(Control.MousePosition)))
                {
                    this.panelBack.Capture = true;
                    this.panelBack.BackgroundImage = Properties.Resources.BackHover;
                }
                else
                {
                    this.panelBack.Capture = false;
                    this.panelBack.BackgroundImage = Properties.Resources.Back;
                }
            }
        }

        /// <summary>
        /// panelBack MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseDown(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                this.panelBack.BackgroundImage = Properties.Resources.BackClicked;
            }
        }

        /// <summary>
        /// panelForward MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseDown(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                this.panelForward.BackgroundImage = Properties.Resources.ForwardClicked;
            }
        }

        /// <summary>
        /// panelBack MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseUp(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                this.panelBack.BackgroundImage = Properties.Resources.Back;
            }
        }

        /// <summary>
        /// panelForward MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseUp(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                this.panelForward.BackgroundImage = Properties.Resources.Forward;
            }
        }

        /// <summary>
        /// panelBack MouseClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseClick(object sender, MouseEventArgs e)
        {
            this.GoBack();
        }

        /// <summary>
        /// panelForward Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_Click(object sender, EventArgs e)
        {
            this.GoForward();
        }

        /// <summary>
        /// Goes back in the history
        /// </summary>
        private void GoBack()
        {
            if ((bool)this.panelBack.Tag)
            {
                this.history[--this.historyIndex].Invoke();

                this.panelForward.Tag = true;
                this.panelForward.BackgroundImage = Properties.Resources.Forward;

                if (this.historyIndex == 0)
                {
                    this.panelBack.Tag = false;
                    this.panelBack.BackgroundImage = Properties.Resources.BackDisabled;
                }
            }
        }

        /// <summary>
        /// Goes forward in the history
        /// </summary>
        private void GoForward()
        {
            if ((bool)this.panelForward.Tag)
            {
                this.history[++this.historyIndex].Invoke();

                this.panelBack.Tag = true;
                this.panelBack.BackgroundImage = Properties.Resources.Back;

                if (this.historyIndex == this.history.Count - 1)
                {
                    this.panelForward.Tag = false;
                    this.panelForward.BackgroundImage = Properties.Resources.ForwardDisabled;
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks DragEnter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Copy;
        }

        /// <summary>
        /// dataGridViewTracks DragDrop event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_DragDrop(object sender, DragEventArgs e)
        {
            string contents = e.Data.GetData(DataFormats.Text).ToString();
            IEnumerable<string> trackList = contents.Split(Environment.NewLine.ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
            trackList = trackList.Where(l => l.StartsWith("http://open.spotify.com/track/")).Select(l => l.Replace("http://open.spotify.com/track/", string.Empty));

            this.ImportTrackList(trackList);
        }

        /// <summary>
        /// Imports a list of tracks
        /// </summary>
        /// <param name="trackList">List of tracks to import</param>
        private void ImportTrackList(IEnumerable<string> trackList)
        {
            BackgroundWorker bw = new BackgroundWorker()
            {
                WorkerReportsProgress = true,
                WorkerSupportsCancellation = true
            };

            this.trackDataSet.Clear();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                int i = 0;
                foreach (string href in trackList)
                {
                    if (bw.CancellationPending)
                    {
                        return;
                    }

                    bw.ReportProgress(0, new Tuple<int, int>(++i, trackList.Count()));

                    Track track = null;
                    if (cachedLookupTracks.ContainsKey(href))
                    {
                        track = cachedLookupTracks[href];
                    }
                    else
                    {
                        string path = Path.Combine(Application.UserAppDataPath, "Lookup", "Tracks", href + ".xml");
                        if (File.Exists(path))
                        {
                            track = SpotifyService.Deserialize<Track>(File.ReadAllText(path));
                            track.Href = "spotify:track:" + href;
                        }
                        else
                        {
                            track = lookup.Value.LookupTrack(href);
                            SpotifyService.Serialize(track, path);
                            track.Href = "spotify:track:" + href;
                        }

                        this.cachedLookupTracks[href] = track;
                    }

                    TrackEx trackEx = new TrackEx(track);
                    this.trackDataSet.Add(trackEx);
                    bw.ReportProgress(0, trackEx);
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                if (bwArgs.UserState is Tuple<int, int>)
                {
                    Tuple<int, int> status = bwArgs.UserState as Tuple<int, int>;
                    this.SetStatus(string.Format(Properties.Resources.GatheringTrackInfo, status.Item1, status.Item2));
                    this.SetProgressBar(status.Item1);
                }
                else if (bwArgs.UserState is TrackEx)
                {
                    TrackEx t = bwArgs.UserState as TrackEx;
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewTracks, t.DiscNumber, t.TrackNumber, t.Name, t.Artist.Name, TimeSpan.FromSeconds((double)t.Length).ToString(@"m\:ss"), this.GetPopularityImage(t.Popularity), t.Album.Name);
                    row.Cells[(int)TrackColumns.Popularity].Tag = t.Popularity;
                    row.Cells[(int)TrackColumns.Time].Tag = t.Length;
                    row.Tag = t;
                    row.Height = 42;

                    this.dataGridViewTracks.Rows.Add(row);
                    this.PopulateArtistFilter(t);
                    this.PopulateAlbumFilter(t);
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.HideProgressBar();
                this.ClearStatus();
            };

            this.dataGridViewAlbums.Rows.Clear();
            this.dataGridViewArtists.Rows.Clear();
            this.dataGridViewTracks.Rows.Clear();

            this.dataGridViewArtists.Tag = null;
            this.dataGridViewAlbums.Tag = null;

            if (trackList.Any())
            {
                this.SetProgressBar(0, trackList.Count());
                bw.RunWorkerAsync();
            }
        }

        /// <summary>
        /// dataGridViewArtists CellMouseEnter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewArtists_CellMouseEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0 && e.RowIndex < this.dataGridViewArtists.Rows.Count)
            {
                DataGridViewRow row = this.dataGridViewArtists.Rows[e.RowIndex];
                row.DefaultCellStyle.BackColor = Color.FromArgb(28, 28, 31);

                if (row.Selected)
                {
                    row.DefaultCellStyle.SelectionBackColor = Color.FromArgb(28, 28, 31);
                }
            }
        }

        /// <summary>
        /// dataGridViewArtists CellMouseLeave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewArtists_CellMouseLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0 && e.RowIndex < this.dataGridViewTracks.Rows.Count)
            {
                DataGridViewRow row = this.dataGridViewArtists.Rows[e.RowIndex];
                row.DefaultCellStyle.BackColor = this.dataGridViewArtists.DefaultCellStyle.BackColor;

                if (row.Selected)
                {
                    row.DefaultCellStyle.SelectionBackColor = this.dataGridViewTracks.DefaultCellStyle.SelectionBackColor;
                }
            }
        }

        /// <summary>
        /// dataGridViewArtists SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewArtists_SelectionChanged(object sender, EventArgs e)
        {
            if (this.dataGridViewArtists.Rows.Count < 3)
            {
                // Return if the data grid hasn't been fully populated, yet or if there's only one artist,
                // switching between "All artists" and the artist will give the same results
                return;
            }

            if (this.dataGridViewArtists.Rows[0].Selected)
            {
                foreach (DataGridViewRow row in this.dataGridViewArtists.SelectedRows)
                {
                    if (row.Index != 0)
                    {
                        row.Selected = false;
                    }
                }

                this.trackDataSetFiltered = this.trackDataSet;
                this.PopulateTracks();
                this.PopulateAlbumFilter();
            }
            else if (this.dataGridViewArtists.SelectedRows.Count > 0)
            {
                List<string> selectedArtistHrefs = new List<string>();
                foreach (DataGridViewRow row in this.dataGridViewArtists.SelectedRows)
                {
                    selectedArtistHrefs.Add((row.Tag as TrackEx).Artist.Href);
                }

                this.trackDataSetFiltered = this.trackDataSet.Where(t => selectedArtistHrefs.Contains(t.Artist.Href)).ToList();
                this.PopulateTracks();
                this.PopulateAlbumFilter(selectedArtistHrefs);
            }

            if (this.dataGridViewAlbums.Rows.Count > 0)
            {
                this.dataGridViewAlbums.Rows[0].Selected = true;
            }
        }

        /// <summary>
        /// dataGridViewArtists SortCompare event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewArtists_SortCompare(object sender, DataGridViewSortCompareEventArgs e)
        {
            if (e.RowIndex1 == 0 || e.RowIndex2 == 0)
            {
                e.Handled = true;
            }
        }

        /// <summary>
        /// dataGridViewAlbums CellMouseEnter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewAlbums_CellMouseEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0 && e.RowIndex < this.dataGridViewAlbums.Rows.Count)
            {
                DataGridViewRow row = this.dataGridViewAlbums.Rows[e.RowIndex];
                row.DefaultCellStyle.BackColor = Color.FromArgb(28, 28, 31);

                if (row.Selected)
                {
                    row.DefaultCellStyle.SelectionBackColor = Color.FromArgb(28, 28, 31);
                }
            }
        }

        /// <summary>
        /// dataGridViewAlbums CellMouseLeave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewAlbums_CellMouseLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0 && e.RowIndex < this.dataGridViewAlbums.Rows.Count)
            {
                DataGridViewRow row = this.dataGridViewAlbums.Rows[e.RowIndex];
                row.DefaultCellStyle.BackColor = this.dataGridViewArtists.DefaultCellStyle.BackColor;

                if (row.Selected)
                {
                    row.DefaultCellStyle.SelectionBackColor = this.dataGridViewTracks.DefaultCellStyle.SelectionBackColor;
                }
            }
        }

        /// <summary>
        /// dataGridViewAlbums SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewAlbums_SelectionChanged(object sender, EventArgs e)
        {
            if (this.dataGridViewAlbums.Rows.Count < 3)
            {
                // Return if the data grids hasn't been fully populated, yet or if there's only one album,
                // switching between "All albums" and the album will give the same results
                return;
            }

            List<string> selectedArtistHrefs = new List<string>();
            bool allArtistsSelected = this.dataGridViewArtists.Rows[0].Selected;
            foreach (DataGridViewRow row in this.dataGridViewArtists.Rows)
            {
                if (row.Index != 0 && (allArtistsSelected || row.Selected))
                {
                    selectedArtistHrefs.Add((row.Tag as TrackEx).Artist.Href);
                }
            }

            List<string> selectedAlbumHrefs = new List<string>();
            if (dataGridViewAlbums.Rows[0].Selected)
            {
                foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
                {
                    if (row.Index != 0)
                    {
                        row.Selected = false;

                        if (row.Visible)
                        {
                            selectedAlbumHrefs.Add((row.Tag as AlbumEx).Href);
                        }
                    }
                }
            }
            else
            {
                foreach (DataGridViewRow row in this.dataGridViewAlbums.SelectedRows)
                {
                    selectedAlbumHrefs.Add((row.Tag as AlbumEx).Href);
                }
            }

            this.trackDataSetFiltered = this.GroupAndSortTracks(this.trackDataSet.Where(t => selectedAlbumHrefs.Contains(t.Album.Href) && (allArtistsSelected || selectedArtistHrefs.Contains(t.Artist.Href))).ToList());
            this.PopulateTracks();
        }

        /// <summary>
        /// dataGridViewAlbums SortCompare event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewAlbums_SortCompare(object sender, DataGridViewSortCompareEventArgs e)
        {
            if (e.RowIndex1 == 0 || e.RowIndex2 == 0)
            {
                e.Handled = true;
            }
        }

        /// <summary>
        /// Sets the value of the progress bar
        /// </summary>
        /// <param name="valueToSet">Value to set</param>
        /// <param name="maxValueToSet">Maximum value to set</param>
        private void SetProgressBar(int valueToSet, int maxValueToSet = -1)
        {
            if (maxValueToSet >= 0)
            {
                this.progressBar.Maximum = maxValueToSet;
                this.progressBar.Visible = true;
            }

            this.progressBar.Value = valueToSet;
        }

        /// <summary>
        /// Hides the progress bar
        /// </summary>
        private void HideProgressBar()
        {
            this.progressBar.Visible = false;
        }

        /// <summary>
        /// toolStripMenuItemFindDuplicates Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripMenuItemFindDuplicates_Click(object sender, EventArgs e)
        {
            var tuples = new List<Tuple<double, DataGridViewRow, DataGridViewRow>>();
            BackgroundWorker bw = new BackgroundWorker() { WorkerReportsProgress = true };
            bw.DoWork += (bwSender, bwArgs) =>
            {
                for (int i = 0; i < this.dataGridViewTracks.Rows.Count - 1; i++)
                {
                    bw.ReportProgress(0, i);
                    for (int j = i + 1; j < this.dataGridViewTracks.Rows.Count; j++)
                    {
                        object track1 = this.dataGridViewTracks.Rows[i].Tag;
                        object track2 = this.dataGridViewTracks.Rows[j].Tag;
                        double similarity = TrackComparer.Compare(track1, track2);
                        tuples.Add(new Tuple<double, DataGridViewRow, DataGridViewRow>(similarity, this.dataGridViewTracks.Rows[i], this.dataGridViewTracks.Rows[j]));
                    }
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                int count = (int)bwArgs.UserState + 1;
                this.SetProgressBar(count, this.dataGridViewTracks.Rows.Count);
                this.SetStatus(string.Format(Properties.Resources.FindingDuplicates, count, this.dataGridViewTracks.Rows.Count));
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.ClearStatus();
                this.HideProgressBar();
                this.SetBusyState(false);

                tuples = tuples.Where(t => t.Item1 > 80).OrderBy(t => t.Item1).Reverse().ToList();

                if (tuples.Any())
                {
                    this.dataGridViewTracks.Rows.Clear();
                    foreach (var tuple in tuples)
                    {
                        if (!this.dataGridViewTracks.Rows.Contains(tuple.Item2))
                        {
                            this.dataGridViewTracks.Rows.Add(tuple.Item2);
                        }

                        if (!this.dataGridViewTracks.Rows.Contains(tuple.Item3))
                        {
                            this.dataGridViewTracks.Rows.Add(tuple.Item3);
                        }
                    }
                }
                else
                {
                    MessageBox.Show(Properties.Resources.NoDuplicatesFound, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            };

            this.SetBusyState(true);
            bw.RunWorkerAsync();
        }

        /// <summary>
        /// toolStripMenuItemPlay Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripMenuItemPlay_Click(object sender, EventArgs e)
        {
            List<int> indices = new List<int>();
            foreach (DataGridViewRow row in this.dataGridViewTracks.SelectedRows)
            {
                indices.Add(row.Index);
            }

            if (indices.Any())
            {
                this.PlayTrackset(indices.Min());
            }
        }

        /// <summary>
        /// toolStripMenuItemPlay Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripMenuItemPlaySelected_Click(object sender, EventArgs e)
        {
            if (this.dataGridViewTracks.SelectedRows.Count == 0)
            {
                return;
            }

            List<int> indices = new List<int>();
            foreach (DataGridViewRow row in this.dataGridViewTracks.SelectedRows)
            {
                indices.Add(row.Index);
            }

            List<string> tracks = new List<string>();
            foreach (int i in indices.OrderBy(i => i))
            {
                tracks.Add((this.dataGridViewTracks.Rows[i].Tag as TrackEx).Href.Replace("spotify:track:", string.Empty));
            }

            if (tracks.Any())
            {
                string trackset = "spotify:trackset:SpotCon:" + string.Join(",", tracks);
                this.SendToServer(trackset + "|Play");
            }
        }

        /// <summary>
        /// dataGridViewPlaylists SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewPlaylists_SelectionChanged(object sender, EventArgs e)
        {
            HashSet<string> tracks = new HashSet<string>();
            foreach (DataGridViewRow row in this.dataGridViewPlaylists.SelectedRows)
            {
                PlaylistEx playlist = row.Tag as PlaylistEx;
                tracks.UnionWith(playlist.Tracks);
            }

            this.ImportTrackList(tracks);
        }

        /// <summary>
        /// addPlaylistToolStripMenuItem Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void addPlaylistToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.OpenSpotConApp();

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                bwArgs.Result = new PlaylistEx(webHelper.Value.GetLatestPlaylist());
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                PlaylistEx newPlaylist = bwArgs.Result as PlaylistEx;
                if (newPlaylist.IsEmpty)
                {
                    if (DialogResult.OK == MessageBox.Show(this, Properties.Resources.AddPlaylistMessage, Properties.Resources.AddPlaylistCaption, MessageBoxButtons.OKCancel, MessageBoxIcon.Information))
                    {
                        bw.RunWorkerAsync();
                    }
                }
                else
                {
                    DataGridViewRow row = null;
                    var playlists = GetPlaylistCache();
                    if (playlists.ContainsKey(newPlaylist.Uri))
                    {
                        foreach (DataGridViewRow r in this.dataGridViewPlaylists.Rows)
                        {
                            if ((r.Tag as PlaylistEx).Uri.Equals(newPlaylist.Uri, StringComparison.OrdinalIgnoreCase))
                            {
                                row = r;
                                break;
                            }
                        }

                        row.Cells[0].Value = newPlaylist.Name;
                        row.Tag = newPlaylist;
                        row.Selected = true;

                        this.UpdatePlaylistCache(newPlaylist);
                    }
                    else
                    {
                        row = new DataGridViewRow();
                        row.CreateCells(this.dataGridViewPlaylists, newPlaylist.Name);
                        row.Tag = newPlaylist;
                        this.dataGridViewPlaylists.Rows.Add(row);
                        row.Selected = true;

                        this.AddToPlaylistCache(newPlaylist);
                    }
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// refreshPlaylistToolStripMenuItem Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void refreshPlaylistToolStripMenuItem_Click(object sender, EventArgs e)
        {
            List<DataGridViewRow> rows = new List<DataGridViewRow>();
            foreach (DataGridViewRow row in this.dataGridViewPlaylists.SelectedRows)
            {
                rows.Add(row);
            }

            this.RefreshPlaylistRows(rows);
        }

        /// <summary>
        /// Refreshes the given playists
        /// </summary>
        /// <param name="rows">Rows of playlists to refresh</param>
        private void RefreshPlaylistRows(List<DataGridViewRow> rows)
        {
            if (!rows.Any())
            {
                return;
            }

            this.OpenSpotConApp();
            HashSet<string> tracks = new HashSet<string>();
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (rows.Any())
                {
                    PlaylistEx currentPlaylist = rows[0].Tag as PlaylistEx;
                    bwArgs.Result = new Tuple<PlaylistEx, PlaylistEx>(currentPlaylist, new PlaylistEx(webHelper.Value.GetPlaylist(currentPlaylist.Uri)));
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                Tuple<PlaylistEx, PlaylistEx> playlists = bwArgs.Result as Tuple<PlaylistEx, PlaylistEx>;

                if (playlists != null)
                {
                    PlaylistEx currentPlaylist = playlists.Item1;
                    PlaylistEx newPlaylist = playlists.Item2;

                    if (newPlaylist.IsEmpty)
                    {
                        string message = string.Format(Properties.Resources.RefreshPlaylistMessage, currentPlaylist.Name);
                        if (DialogResult.OK == MessageBox.Show(this, message, Properties.Resources.RefreshPlaylistCaption, MessageBoxButtons.OKCancel, MessageBoxIcon.Information))
                        {
                            bw.RunWorkerAsync();
                        }
                    }
                    else if (!newPlaylist.IsEmpty)
                    {
                        rows[0].Cells[0].Value = newPlaylist.Name;
                        rows[0].Tag = newPlaylist;

                        this.UpdatePlaylistCache(newPlaylist);
                        tracks.UnionWith(newPlaylist.Tracks);
                        rows.RemoveAt(0);
                        bw.RunWorkerAsync();
                    }
                }
                else if (tracks.Any())
                {
                    ImportTrackList(tracks);
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// refreshAllPlaylistsToolStripMenuItem Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void refreshAllPlaylistsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            List<DataGridViewRow> rows = new List<DataGridViewRow>();
            foreach (DataGridViewRow row in this.dataGridViewPlaylists.Rows)
            {
                rows.Add(row);
            }

            this.RefreshPlaylistRows(rows);
        }

        /// <summary>
        /// removePlaylistToolStripMenuItem Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void removePlaylistToolStripMenuItem_Click(object sender, EventArgs e)
        {
            List<int> rowIndices = new List<int>();
            foreach (DataGridViewRow row in this.dataGridViewPlaylists.SelectedRows)
            {
                rowIndices.Add(row.Index);
            }

            if (!rowIndices.Any())
            {
                return;
            }

            Dictionary<string, PlaylistEx> playlists = this.GetPlaylistCache();
            foreach (int index in rowIndices.OrderByDescending(i => i).Select(i => i))
            {
                PlaylistEx playlist = this.dataGridViewPlaylists.Rows[index].Tag as PlaylistEx;
                if (playlists.ContainsKey(playlist.Uri))
                {
                    playlists.Remove(playlist.Uri);
                }

                this.dataGridViewPlaylists.Rows[index].Selected = false;
                this.dataGridViewPlaylists.Rows.RemoveAt(index);
            }

            this.ReplacePlaylistCache(playlists);
        }

        /// <summary>
        /// Opens the SpotCon app inside Spotify
        /// </summary>
        private void OpenSpotConApp()
        {
            SetForegroundWindow(this.spotifyHwnd);
            System.Threading.Thread.Sleep(100);
            SendKeys.Send("^l");
            System.Threading.Thread.Sleep(100);
            SendKeys.Send("spotify:app:spotcon");
            System.Threading.Thread.Sleep(100);
            SendKeys.Send("{ENTER}");
            SetForegroundWindow(this.Handle);
        }

        /// <summary>
        /// SpotConForm FormClosing event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (this.iisExpress != null && !this.iisExpress.HasExited)
            {
                const uint GW_HWNDNEXT = 2;
                for (IntPtr pointer = GetTopWindow(IntPtr.Zero); pointer != IntPtr.Zero; pointer = GetWindow(pointer, GW_HWNDNEXT))
                {
                    uint processId;
                    GetWindowThreadProcessId(pointer, out processId);

                    if (this.iisExpress.Id == processId)
                    {
                        const uint WM_QUIT = 0x12;
                        HandleRef hWnd = new HandleRef(null, pointer);
                        PostMessage(hWnd, WM_QUIT, IntPtr.Zero, IntPtr.Zero);
                        this.iisExpress.Close();
                        return;
                    }
                }
            }
        }

        /// <summary>
        /// Represents a packet
        /// </summary>
        public class SocketPacket
        {
            /// <summary>
            /// Initializes a new instance of the SocketPacket class
            /// </summary>
            public SocketPacket()
            {
                this.Buffer = new byte[1];
            }

            /// <summary>
            /// Gets or sets the corresponding socket
            /// </summary>
            public Socket Socket { get; set; }

            /// <summary>
            /// Gets or sets the buffer to store packet data
            /// </summary>
            public byte[] Buffer { get; set; }
        }

        /// <summary>
        /// Represents host information
        /// </summary>
        public class HostData
        {
            /// <summary>
            /// Gets or sets the hosts' IP address
            /// </summary>
            public IPAddress IPAddress { get; set; }

            /// <summary>
            /// Gets or sets the host's associated socket
            /// </summary>
            public Socket Socket { get; set; }

            /// <summary>
            /// Gets or sets the hosts' connection status
            /// </summary>
            public ClientConnectStatus ConnectionStatus { get; set; }

            /// <summary>
            /// Gets or sets the associated row in the host data grid
            /// </summary>
            public DataGridViewRow Row { get; set; }

            /// <summary>
            /// Gets or sets the timer used to update the Spotify status
            /// </summary>
            public Timer Timer { get; set; }
        }
    }
}