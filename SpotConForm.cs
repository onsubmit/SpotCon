//-----------------------------------------------------------------------
// <copyright file="SpotConForm.cs" company="Andy Young">
//     Copyright (c) Andy Young. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace SpotCon
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.DirectoryServices;
    using System.Drawing;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Web;
    using System.Windows.Forms;
    using System.Xml.Linq;
    using SpotCon.PlaylistImporter;
    using SpotifyWebHelperSharp;
    using SpotifyWebSharp.SpotifyResponses.Lookup;
    using SpotifyWebSharp.SpotifyResponses.Search;
    using SpotifyWebSharp.SpotifyServices;

    /// <summary>
    /// Main form
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.NamingRules", "SA1300:ElementMustBeginWithUpperCaseLetter", Justification = "WinForms autogenerated method names.")]
    [SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1650:ElementDocumentationMustBeSpelledCorrectly", Justification = "'Spotify' is spelled correctly, dummy.")]
    public partial class SpotConForm : Form
    {
        /// <summary>
        /// WM_APPCOMMAND
        /// <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms646275(v=vs.85).aspx</remarks>
        /// </summary>
        private const int WM_APPCOMMAND = 0x0319;

        /// <summary>
        /// VK_CONTROL
        /// </summary>
        private const int VK_CONTROL = 0x11;

        /// <summary>
        /// VK_DOWN
        /// </summary>
        private const int WM_KEYDOWN = 0x0100;

        /// <summary>
        /// WM_KEYDOWN
        /// </summary>
        private const int WM_KEYUP = 0x0101;

        /// <summary>
        /// VK_UP
        /// </summary>
        private const int VK_UP = 0x26;

        /// <summary>
        /// VK_DOWN
        /// </summary>
        private const int VK_DOWN = 0x28;

        /// <summary>
        /// APPCOMMAND_VOLUME_MUTE (8)
        /// </summary>
        private const int APPCOMMAND_VOLUME_MUTE = 524288;

        /// <summary>
        /// APPCOMMAND_VOLUME_DOWN (9)
        /// </summary>
        private const int APPCOMMAND_VOLUME_DOWN = 589824;

        /// <summary>
        /// APPCOMMAND_VOLUME_UP (10)
        /// </summary>
        private const int APPCOMMAND_VOLUME_UP = 655360;

        /// <summary>
        /// APPCOMMAND_MEDIA_NEXTTRACK (11)
        /// </summary>
        private const int APPCOMMAND_MEDIA_NEXTTRACK = 720896;

        /// <summary>
        /// APPCOMMAND_MEDIA_PREVIOUSTRACK (12)
        /// </summary>
        private const int APPCOMMAND_MEDIA_PREVIOUSTRACK = 786432;

        /// <summary>
        /// APPCOMMAND_MEDIA_STOP (13)
        /// </summary>
        private const int APPCOMMAND_MEDIA_STOP = 851968;

        /// <summary>
        /// APPCOMMAND_MEDIA_PLAY_PAUSE (14)
        /// </summary>
        private const int APPCOMMAND_MEDIA_PLAY_PAUSE = 917504;

        /// <summary>
        /// TCP port to use
        /// </summary>
        private const int Port = 1729;

        /// <summary>
        /// Lock for sending packets
        /// </summary>
        private readonly object sendLock = new object();

        /// <summary>
        /// Lock for receiving packets
        /// </summary>
        private readonly object receiveLock = new object();

        /// <summary>
        /// Data grid alternate style
        /// </summary>
        private DataGridViewCellStyle alternateStyle;

        /// <summary>
        /// The name of the current host
        /// </summary>
        private string currentHost;

        /// <summary>
        /// The name of the currently selected host
        /// </summary>
        private string selectedHost;

        /// <summary>
        /// Buffer for server input
        /// </summary>
        private string inputFromServer;

        /// <summary>
        /// Buffer for client input
        /// </summary>
        private string inputFromClient;

        /// <summary>
        /// The current status of Spotify
        /// </summary>
        private Responses.Status currentStatus;

        /// <summary>
        /// The number of milliseconds to wait between each attempt to update status from Spotify
        /// </summary>
        private int defaultWaitTime = 1000;

        /// <summary>
        /// Server listener socket
        /// </summary>
        private Socket listener;

        /// <summary>
        /// Asynchronous callback for server
        /// </summary>
        private AsyncCallback callbackServer;

        /// <summary>
        /// Asynchronous callback for client
        /// </summary>
        private AsyncCallback callbackClient;

        /// <summary>
        /// Temporary placeholder for newly created server worker sockets
        /// </summary>
        private Socket newWorker;

        /// <summary>
        /// Host images
        /// </summary>
        private ImageList hostImages = new ImageList();

        /// <summary>
        /// Popularity images
        /// </summary>
        private ImageList popImages = new ImageList();

        /// <summary>
        /// Popularity images (selected)
        /// </summary>
        private ImageList popSelectedImages = new ImageList();

        /// <summary>
        /// List of commands that execute in response to client or server requests
        /// </summary>
        private Dictionary<string, Action<string, string, string>> commands;

        /// <summary>
        /// List of collections and their corresponding tracks
        /// </summary>
        private Dictionary<string, HashSet<string>> collections = new Dictionary<string, HashSet<string>>();

        /// <summary>
        /// Maps artist name to a Spotify artist href
        /// </summary>
        /// <example>The Naked and Famous|||spotify:artist:0oeUpvxWsC8bWS6SnpU8b9</example>
        private Dictionary<string, string> cachedArtistHrefs = new Dictionary<string, string>();

        /// <summary>
        /// Maps artist name input to actual Spotify artist name
        /// </summary>
        /// <example>Smashing Pumpkins|||The Smashing Pumpkins</example>
        private Dictionary<string, string> misspelledArtists = new Dictionary<string, string>();

        /// <summary>
        /// Maps artist name and track name input to actual Spotify track name
        /// </summary>
        /// <example>spotify:artist:4tZwfgrHOc3mvqYlEYSvVi:::Get Lucky (feat. Pharrell Williams &amp; Nile Rodgers)|||Get Lucky</example>
        private Dictionary<string, string> misspelledTracks = new Dictionary<string, string>();

        /// <summary>
        /// Maps track ID to Lookup Track
        /// </summary>
        private Dictionary<string, Track> cachedLookupTracks = new Dictionary<string, Track>();

        /// <summary>
        /// Maps artist href to Lookup Album
        /// </summary>
        private Dictionary<string, Album> cachedLookupAlbums = new Dictionary<string, Album>();

        /// <summary>
        /// Maps artist (href) and track name combination to Spotify Search Track
        /// </summary>
        /// <example>spotify:artist:3jOstUTkEu2JkjvRdBA5Gu:::Buddy Holly -> SearchTrack serialized on disk</example>
        private Dictionary<string, SearchTrack> cachedSearchTracks = new Dictionary<string, SearchTrack>();

        /// <summary>
        /// Tracks that couldn't be immediately identified by the Search service
        /// </summary>
        private Queue<FindNewTracksThreadStatus> unknownTracks = new Queue<FindNewTracksThreadStatus>();

        /// <summary>
        /// Tracks whose identification process was skipped
        /// </summary>
        private List<string> skippedTracks = new List<string>();

        /// <summary>
        /// Used to retrieve status from Spotify
        /// </summary>
        private Lazy<SpotifyWebHelper> webHelper = new Lazy<SpotifyWebHelper>(() => { return new SpotifyWebHelper(); });

        /// <summary>
        /// Host information
        /// </summary>
        private Dictionary<string, HostData> hostData = new Dictionary<string, HostData>();

        /// <summary>
        /// Server worker sockets
        /// </summary>
        private Dictionary<string, Socket> workers = new Dictionary<string, Socket>();

        /// <summary>
        /// Tracks the list of selected track row indices
        /// </summary>
        private List<int> selectedTrackRowIndices = new List<int>();

        /// <summary>
        /// Handle to Spotify window
        /// </summary>
        private IntPtr spotifyHwnd = IntPtr.Zero;

        /// <summary>
        /// Spotify Search service
        /// </summary>
        private Lazy<SearchService> search = new Lazy<SearchService>(() => { return new SearchService(); });

        /// <summary>
        /// Spotify Lookup service
        /// </summary>
        private Lazy<LookupService> lookup = new Lazy<LookupService>(() => { return new LookupService(); });

        /// <summary>
        /// Tooltip for track
        /// </summary>
        private ToolTip tooltipTrack = new ToolTip();

        /// <summary>
        /// Tooltip for artist
        /// </summary>
        private ToolTip tooltipArtist = new ToolTip();

        /// <summary>
        /// History of actions that can be traversed
        /// </summary>
        private List<Action> history = new List<Action>();

        /// <summary>
        /// Current index in the history
        /// </summary>
        private int historyIndex = 0;

        /// <summary>
        /// Indicates if the form was previously maximized
        /// </summary>
        private bool wasMaximized = false;

        /// <summary>
        /// The relative width of the collections data grid
        /// </summary>
        private double collectionPercentage;

        /// <summary>
        /// The relative width of the album data grid
        /// </summary>
        private double albumPercentage;

        /// <summary>
        /// Initializes a new instance of the SpotConForm class
        /// </summary>
        public SpotConForm()
        {
            this.InitializeComponent();

            this.commands = new Dictionary<string, Action<string, string, string>>()
            {
                {
                    "|Connected",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        this.workers[orig] = this.newWorker;

                        if (orig != currentHost)
                        {
                            this.SetStatus(string.Format(Properties.Resources.ClientConnected, orig));
                        }
                    })
                },
                {
                    "|Previous",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, WM_APPCOMMAND, 0, APPCOMMAND_MEDIA_PREVIOUSTRACK);
                    })
                },
                {
                    "|Play",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        if (s.StartsWith("http://open.spotify.com/trackset/Spotify/"))
                        {
                            Process p = Process.Start(s);
                            if (p != null)
                            {
                                p.Close();
                                p.WaitForExit();
                            }
                        }
                        else
                        {
                            this.webHelper.Value.Play(s);
                        }
                    })
                },
                {
                    "|Next",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, WM_APPCOMMAND, 0, APPCOMMAND_MEDIA_NEXTTRACK);
                    })
                },
                {
                    "|Pause",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, WM_APPCOMMAND, 0, APPCOMMAND_MEDIA_PLAY_PAUSE);
                    })
                },
                {
                    "|SetVolume",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        string[] split = s.Split(':');
                        double desired = 0;
                        double.TryParse(split[0], out desired);

                        double current = 0;
                        double.TryParse(split[1], out current);

                        string action = desired < current ? "{DOWN}" : "{UP}";

                        bool success = SetForegroundWindow(this.spotifyHwnd);
                        for (int i = 0; i <= 100 * Math.Abs((desired - current) / 6.25); i++)
                        {
                            System.Threading.Thread.Sleep(10);
                            SendKeys.Send(string.Format("^({0})", action));
                            System.Threading.Thread.Sleep(10);
                        }

                        if (dest == this.currentHost)
                        {
                            success = SetForegroundWindow(this.Handle);
                        }
                    })
                },
                {
                    "|GetStatusFromServer",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        string response = string.Empty;
                        webHelper.Value.GetStatus(out response);
                        this.SendToClient(response + "|ServerStatusReturned", orig);
                    })
                },
                {
                    "|ServerStatusReturned",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        Responses.Status status = webHelper.Value.Deserialize<Responses.Status>(s);
                        bool success = this.UpdateStatus(status);
                        string currentAlbumUri = this.currentStatus == null || this.currentStatus.Track == null ? null : this.currentStatus.Track.AlbumResource.Uri;
                        this.currentStatus = status;

                        if (success && status.Track.AlbumResource.Uri != currentAlbumUri)
                        {
                            BackgroundWorker bw = new BackgroundWorker();
                            bw.DoWork += (bwSender, bwArgs) =>
                            {
                                Tuple<string, string> art = webHelper.Value.GetArt(status.Track);
                                bwArgs.Result = art;
                            };

                            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
                            {
                                Tuple<string, string> art = bwArgs.Result as Tuple<string, string>;
                                pictureBox.LoadAsync(art.Item2);
                            };

                            bw.RunWorkerAsync();
                        }
                    })
                }
            };
        }

        /// <summary>
        /// Represents the connect status of the client
        /// </summary>
        public enum ClientConnectStatus
        {
            /// <summary>
            /// Client is disconnected
            /// </summary>
            Disconnected,

            /// <summary>
            /// Client is connected
            /// </summary>
            Connected,

            /// <summary>
            /// Client couldn't connect
            /// </summary>
            ConnectionFailure
        }

        /// <summary>
        /// Represents a column in the host data grid
        /// </summary>
        public enum HostColumns
        {
            /// <summary>
            /// Checkbox column
            /// </summary>
            Checkbox,

            /// <summary>
            /// Connection status column
            /// </summary>
            ConnectionStatus,

            /// <summary>
            /// Name column
            /// </summary>
            Name
        }

        /// <summary>
        /// Represents a column in the tracks data grid
        /// </summary>
        public enum TrackColumns
        {
            /// <summary>
            /// Padding column
            /// </summary>
            Padding,

            /// <summary>
            /// Track number
            /// </summary>
            TrackNumber,

            /// <summary>
            /// Track column
            /// </summary>
            Track,

            /// <summary>
            /// Artist column
            /// </summary>
            Artist,

            /// <summary>
            /// Time column
            /// </summary>
            Time,

            /// <summary>
            /// Popularity column
            /// </summary>
            Popularity,

            /// <summary>
            /// Album column
            /// </summary>
            Album
        }

        /// <summary>
        /// Represents the type of search that is occurring
        /// </summary>
        public enum SearchType
        {
            /// <summary>
            /// Artist search
            /// </summary>
            Artist,

            /// <summary>
            /// Album search
            /// </summary>
            Album,

            /// <summary>
            /// Track search
            /// </summary>
            Track
        }

        /// <summary>
        /// Sends the specified message to a window or windows.
        /// The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose window procedure will receive the message.</param>
        /// <param name="msg">The message to be sent.</param>
        /// <param name="wParam">Additional message-specific information. (UINT_PTR)</param>
        /// <param name="lParam">Additional message-specific information. (LONG_PTR)</param>
        /// <returns>The return value specifies the result of the message processing; it depends on the message sent.</returns>
        [DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint msg, int wParam, int lParam);

        /// <summary>
        /// Brings the thread that created the specified window into the foreground and activates the window.
        /// </summary>
        /// <param name="hWnd">A handle to the window that should be activated and brought to the foreground.</param>
        /// <returns>If the window was brought to the foreground, the return value is nonzero. Zero otherwise.</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        /// <summary>
        /// Invoked when a new client connects
        /// </summary>
        /// <param name="result">Connection result</param>
        private void OnClientConnect(IAsyncResult result)
        {
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                try
                {
                    // Complete the BeginAccept() asynchronous call by calling EndAccept() which returns a reference to the new socket
                    Socket socket = this.listener.EndAccept(result);
                    this.newWorker = socket;

                    // Let the worker socket do further processing for the just connected client
                    WaitForDataServer(socket);

                    // Since the main socket is now free, it can go back and wait for other clients who are attempting to connect
                    listener.BeginAccept(new AsyncCallback(OnClientConnect), null);
                }
                catch (ObjectDisposedException)
                {
                    System.Diagnostics.Debugger.Log(0, "1", "\n OnClientConnection: Socket has been closed\n");
                }
                catch (Exception ex)
                {
                    bwArgs.Result = ex;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (bwArgs.Result is Exception && this.InvokeRequired)
                {
                    this.BeginInvoke((Delegate)(new Action(() => this.SetStatusError((bwArgs.Result as Exception).Message))));
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Invoked when data is received by the server
        /// </summary>
        /// <param name="result">Data result</param>
        private void OnDataReceivedByServer(IAsyncResult result)
        {
            SocketPacket packet = (SocketPacket)result.AsyncState;

            // Complete the BeginReceive() asynchronous call by the EndReceive() method which will return the number of characters written to the stream by the client
            if (packet.Socket.Connected)
            {
                lock (this.receiveLock)
                {
                    int byteCount = 0;
                    try
                    {
                        byteCount = packet.Socket.EndReceive(result);
                    }
                    catch (SocketException)
                    {
                        return;
                    }

                    char[] chars = new char[byteCount];
                    int charLen = Encoding.UTF8.GetChars(bytes: packet.Buffer, byteIndex: 0, byteCount: byteCount, chars: chars, charIndex: 0);
                    string data = new string(chars);
                    this.inputFromClient += data;

                    foreach (var command in this.commands)
                    {
                        if (this.inputFromClient.EndsWith(command.Key))
                        {
                            string input = this.inputFromClient.Replace(command.Key, string.Empty);
                            this.inputFromClient = string.Empty;

                            string[] split = input.Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                            string originatingClient = split[0];
                            input = split.Length > 1 ? split[1] : string.Empty;

                            if (this.InvokeRequired)
                            {
                                this.BeginInvoke((Delegate)command.Value, this.currentHost, originatingClient, input);
                            }

                            break;
                        }
                    }

                    // Continue the waiting for data on the socket
                    this.WaitForDataServer(packet.Socket);
                }
            }
        }

        /// <summary>
        /// Invoked when data is received by the client
        /// </summary>
        /// <param name="result">Data result</param>
        private void OnDataReceivedByClient(IAsyncResult result)
        {
            SocketPacket packet = (SocketPacket)result.AsyncState;

            // Complete the BeginReceive() asynchronous call by the EndReceive() method which will return the number of characters written to the stream by the client
            if (packet.Socket.Connected)
            {
                lock (this.receiveLock)
                {
                    int byteCount = 0;
                    try
                    {
                        byteCount = packet.Socket.EndReceive(result);
                    }
                    catch (SocketException)
                    {
                        return;
                    }

                    char[] chars = new char[byteCount];
                    int charLen = Encoding.UTF8.GetChars(bytes: packet.Buffer, byteIndex: 0, byteCount: byteCount, chars: chars, charIndex: 0);
                    string data = new string(chars);
                    this.inputFromServer += data;

                    foreach (var command in this.commands)
                    {
                        if (this.inputFromServer.EndsWith(command.Key))
                        {
                            string input = this.inputFromServer.Replace(command.Key, string.Empty);
                            this.inputFromServer = string.Empty;

                            string[] split = input.Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                            string originatingServer = split[0];
                            input = split.Length > 1 ? split[1] : string.Empty;

                            if (this.InvokeRequired)
                            {
                                this.BeginInvoke((Delegate)command.Value, this.currentHost, originatingServer, input);
                            }

                            break;
                        }
                    }

                    // Continue the waiting for data on the socket
                    this.WaitForDataClient(packet.Socket);
                }
            }
        }

        /// <summary>
        /// Invoked when the server begins waiting for data
        /// </summary>
        /// <param name="socket">Server socket</param>
        private void WaitForDataServer(Socket socket)
        {
            try
            {
                if (this.callbackServer == null)
                {
                    // Specify the callback function which is to be invoked when there is any write activity by the connected client
                    this.callbackServer = new AsyncCallback(this.OnDataReceivedByServer);
                }

                SocketPacket socketPacket = new SocketPacket() { Socket = socket };

                // Start receiving any data written by the connected client asynchronously
                socket.BeginReceive(buffer: socketPacket.Buffer, offset: 0, size: socketPacket.Buffer.Length, socketFlags: SocketFlags.None, callback: this.callbackServer, state: socketPacket);
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Invoked when the client begins waiting for data
        /// </summary>
        /// <param name="socket">Client socket</param>
        private void WaitForDataClient(Socket socket)
        {
            try
            {
                if (this.callbackClient == null)
                {
                    // Specify the callback function which is to be invoked when there is any write activity by the connected client
                    this.callbackClient = new AsyncCallback(this.OnDataReceivedByClient);
                }

                SocketPacket socketPacket = new SocketPacket() { Socket = socket };

                // Start receiving any data written by the connected client asynchronously
                socket.BeginReceive(buffer: socketPacket.Buffer, offset: 0, size: socketPacket.Buffer.Length, socketFlags: SocketFlags.None, callback: this.callbackClient, state: socketPacket);
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// SpotConForm Load event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_Load(object sender, EventArgs e)
        {
            this.history.Add(() =>
            {
                this.dataGridViewTracks.Rows.Clear();
                this.ClearStatus();
            });

            this.panelBack.Tag = false;
            this.panelForward.Tag = false;

            this.ActiveControl = this.panelPlayPause;
            this.textBoxSearch.Tag = this.textBoxSearch.ForeColor;

            this.ClearStatus();
            this.SetStatusBusy(Properties.Resources.SearchingNetwork);

            this.hostImages.Images.Add(Properties.Resources.Computer);
            this.hostImages.Images.Add(Properties.Resources.ComputerLink);
            this.hostImages.Images.Add(Properties.Resources.ComputerError);

            this.popImages.ImageSize = new Size(65, 8);
            this.popImages.Images.Add(Properties.Resources.pop00);
            this.popImages.Images.Add(Properties.Resources.pop01);
            this.popImages.Images.Add(Properties.Resources.pop02);
            this.popImages.Images.Add(Properties.Resources.pop03);
            this.popImages.Images.Add(Properties.Resources.pop04);
            this.popImages.Images.Add(Properties.Resources.pop05);
            this.popImages.Images.Add(Properties.Resources.pop06);
            this.popImages.Images.Add(Properties.Resources.pop07);
            this.popImages.Images.Add(Properties.Resources.pop08);
            this.popImages.Images.Add(Properties.Resources.pop09);
            this.popImages.Images.Add(Properties.Resources.pop10);
            this.popImages.Images.Add(Properties.Resources.pop11);
            this.popImages.Images.Add(Properties.Resources.pop12);
            this.popImages.Images.Add(Properties.Resources.pop13);
            this.popImages.Images.Add(Properties.Resources.pop14);
            this.popImages.Images.Add(Properties.Resources.pop15);
            this.popImages.Images.Add(Properties.Resources.pop16);
            this.popImages.Images.Add(Properties.Resources.pop17);
            this.popImages.Images.Add(Properties.Resources.pop18);
            this.popImages.Images.Add(Properties.Resources.pop19);
            this.popImages.Images.Add(Properties.Resources.pop20);
            this.popImages.Images.Add(Properties.Resources.pop21);
            this.popImages.Images.Add(Properties.Resources.pop22);

            this.popSelectedImages.ImageSize = new Size(65, 8);
            this.popSelectedImages.Images.Add(Properties.Resources.pops00);
            this.popSelectedImages.Images.Add(Properties.Resources.pops01);
            this.popSelectedImages.Images.Add(Properties.Resources.pops02);
            this.popSelectedImages.Images.Add(Properties.Resources.pops03);
            this.popSelectedImages.Images.Add(Properties.Resources.pops04);
            this.popSelectedImages.Images.Add(Properties.Resources.pops05);
            this.popSelectedImages.Images.Add(Properties.Resources.pops06);
            this.popSelectedImages.Images.Add(Properties.Resources.pops07);
            this.popSelectedImages.Images.Add(Properties.Resources.pops08);
            this.popSelectedImages.Images.Add(Properties.Resources.pops09);
            this.popSelectedImages.Images.Add(Properties.Resources.pops10);
            this.popSelectedImages.Images.Add(Properties.Resources.pops11);
            this.popSelectedImages.Images.Add(Properties.Resources.pops12);
            this.popSelectedImages.Images.Add(Properties.Resources.pops13);
            this.popSelectedImages.Images.Add(Properties.Resources.pops14);
            this.popSelectedImages.Images.Add(Properties.Resources.pops15);
            this.popSelectedImages.Images.Add(Properties.Resources.pops16);
            this.popSelectedImages.Images.Add(Properties.Resources.pops17);
            this.popSelectedImages.Images.Add(Properties.Resources.pops18);
            this.popSelectedImages.Images.Add(Properties.Resources.pops19);
            this.popSelectedImages.Images.Add(Properties.Resources.pops20);
            this.popSelectedImages.Images.Add(Properties.Resources.pops21);
            this.popSelectedImages.Images.Add(Properties.Resources.pops22);

            Directory.CreateDirectory(Path.Combine(Application.UserAppDataPath, "Lookup", "Tracks"));
            Directory.CreateDirectory(Path.Combine(Application.UserAppDataPath, "Lookup", "Albums"));
            Directory.CreateDirectory(Path.Combine(Application.UserAppDataPath, "Search"));
            this.ReadCollections();
            this.DisplayCollectionList();
            this.LoadImportPlugins();
            this.ReadArtistCache();
            this.ReadMisspelledArtistCache();
            this.ReadMisspelledTrackCache();
            this.ReadCachedTracks();

            this.alternateStyle = new DataGridViewCellStyle(this.dataGridViewTracks.DefaultCellStyle)
            {
                Font = null,
                BackColor = Color.FromArgb(232, 230, 226)
            };

            this.dataGridViewCollections.AlternatingRowsDefaultCellStyle =
            this.dataGridViewArtists.AlternatingRowsDefaultCellStyle =
            this.dataGridViewAlbums.AlternatingRowsDefaultCellStyle =
            this.dataGridViewTracks.AlternatingRowsDefaultCellStyle =
            this.alternateStyle;

            this.collectionPercentage = (double)this.dataGridViewCollections.Width / (double)this.dataGridViewTracks.Width;
            this.albumPercentage = (double)this.dataGridViewAlbums.Width / (double)this.dataGridViewTracks.Width;

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                try
                {
                    listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                    // Bind to local IP address
                    IPEndPoint ipLocal = new IPEndPoint(IPAddress.Any, Port);
                    listener.Bind(ipLocal);

                    // Start listening
                    listener.Listen(backlog: 4);

                    // Create the call back for any client connections...
                    listener.BeginAccept(new AsyncCallback(OnClientConnect), state: null);

                    this.currentHost = Dns.GetHostName().ToUpper();

                    List<string> names;
                    if (Properties.Settings.Default.HostNames == null || Properties.Settings.Default.HostNames.Count == 0)
                    {
                        DirectoryEntry entry = new DirectoryEntry("WinNT:");
                        names = (from DirectoryEntry domains in entry.Children
                                 from DirectoryEntry pc in domains.Children
                                 where pc.SchemaClassName.ToLower().Contains("computer")
                                 select pc.Name.ToUpper()).ToList();

                        if (!names.Any())
                        {
                            names.Add(this.currentHost);
                        }

                        StringCollection sc = new StringCollection();
                        sc.AddRange(names.ToArray());

                        Properties.Settings.Default.HostNames = sc;
                        Properties.Settings.Default.Save();
                        bwArgs.Result = names;
                    }
                    else
                    {
                        bwArgs.Result = names = Properties.Settings.Default.HostNames.Cast<string>().ToList();
                    }

                    foreach (var name in names)
                    {
                        try
                        {
                            if (name.Equals(this.currentHost, StringComparison.OrdinalIgnoreCase))
                            {
                                this.hostData[name] = new HostData() { IPAddress = Dns.GetHostAddresses(name).FirstOrDefault(i => i.AddressFamily == AddressFamily.InterNetwork) };
                            }
                            else
                            {
                                this.hostData[name] = null;
                            }
                        }
                        catch
                        {
                        }
                    }
                }
                catch (Exception ex)
                {
                    bwArgs.Result = ex;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (bwArgs.Result is Exception)
                {
                    Exception ex = bwArgs.Result as Exception;
                    this.SetStatusError(ex.Message);
                    return;
                }
                else
                {
                    List<string> names = bwArgs.Result as List<string>;
                    foreach (var name in names)
                    {
                        try
                        {
                            if (this.hostData.ContainsKey(name))
                            {
                                int index = dataGridViewComputers.Rows.Add(name.Equals(this.currentHost, StringComparison.OrdinalIgnoreCase), hostImages.Images[(int)ClientConnectStatus.Disconnected], name);
                                this.hostData[name].Row = dataGridViewComputers.Rows[index];
                            }
                            else
                            {
                                // TODO: Why is there an empty "else" here?
                            }
                        }
                        catch
                        {
                        }
                    }

                    bool exit = false;
                    Process[] processes = null;

                    while (!exit)
                    {
                        processes = Process.GetProcessesByName("spotify");
                        if (processes.Any())
                        {
                            this.spotifyHwnd = processes[0].MainWindowHandle;
                            break;
                        }

                        if (DialogResult.Cancel == MessageBox.Show(this, Properties.Resources.SpotifyNotFound, this.Text, MessageBoxButtons.RetryCancel, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1))
                        {
                            exit = true;
                        }
                    }

                    if (exit)
                    {
                        Application.Exit();
                    }

                    GlobalMouseHandler globalClick = new GlobalMouseHandler()
                    {
                        BackAction = () => this.GoBack(),
                        ForwardAction = () => this.GoForward()
                    };

                    Application.AddMessageFilter(globalClick);

                    if (names.Contains(this.currentHost))
                    {
                        this.selectedHost = this.currentHost;
                        this.ConnectToServer((int)HostColumns.Checkbox, this.hostData[this.currentHost].Row.Index, this.currentHost);
                    }
                }
            };

            bw.RunWorkerAsync(bw);
        }

        /// <summary>
        /// Displays all the tracks in the collection
        /// </summary>
        /// <param name="specificCollections">Specific collections to display</param>
        private void DisplayCollectionTracks(List<string> specificCollections = null)
        {
            BackgroundWorker bw = new BackgroundWorker() { WorkerReportsProgress = true };
            var tracksToAdd = this.collections.Where(kvp => specificCollections == null || specificCollections.Contains(kvp.Key)).Select(kvp => kvp.Value);
            int numTracks = tracksToAdd.Sum(h => h.Count);

            bw.DoWork += (bwSender, bwArgs) =>
            {
                int i = 0;
                List<Track> tracks = new List<Track>();
                foreach (var hrefs in tracksToAdd)
                {
                    foreach (var href in hrefs)
                    {
                        bw.ReportProgress(0, ++i);
                        Track track = null;
                        if (cachedLookupTracks.ContainsKey(href))
                        {
                            track = cachedLookupTracks[href];
                        }
                        else
                        {
                            string path = Path.Combine(Application.UserAppDataPath, "Lookup", "Tracks", href + ".xml");
                            if (File.Exists(path))
                            {
                                track = SpotifyService.Deserialize<Track>(File.ReadAllText(path));
                            }
                            else
                            {
                                track = lookup.Value.LookupTrack(href);
                                SpotifyService.Serialize(track, path);
                            }

                            track.Href = "spotify:track:" + href;
                            this.cachedLookupTracks[href] = track;
                        }

                        string albumHref = track.Album.Href.Replace("spotify:album:", string.Empty);
                        string albumPath = Path.Combine(Application.UserAppDataPath, "Lookup", "Albums", albumHref + ".xml");

                        Album album = null;
                        if (this.cachedLookupAlbums.ContainsKey(albumHref))
                        {
                            album = this.cachedLookupAlbums[albumHref];
                        }
                        else if (File.Exists(albumPath))
                        {
                            album = SpotifyService.Deserialize<Album>(File.ReadAllText(albumPath));
                        }
                        else
                        {
                            album = lookup.Value.LookupAlbum(albumHref);
                            SpotifyService.Serialize(album, albumPath);
                        }

                        track.Album.Released = album.Released.Value;

                        tracks.Add(track);
                    }
                }

                bwArgs.Result = tracks;
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                int count = (int)bwArgs.UserState;
                this.SetProgressBar(count, numTracks);
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                List<Track> tracks = bwArgs.Result as List<Track>;
                foreach (Track track in tracks)
                {
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewTracks, null, track.TrackNumber, track.Name, track.Artist.Name, TimeSpan.FromSeconds((double)track.Length.Value).ToString(@"m\:ss"), this.GetPopularityImage(track.Popularity), track.Album.Name);
                    row.Cells[(int)TrackColumns.Popularity].Tag = track.Popularity;
                    row.Cells[(int)TrackColumns.Popularity].Style = new DataGridViewCellStyle(row.DefaultCellStyle) { Alignment = DataGridViewContentAlignment.MiddleCenter };
                    row.Cells[(int)TrackColumns.Time].Tag = track.Length.Value;
                    row.Tag = track;
                    this.dataGridViewTracks.Rows.Add(row);
                }

                this.PopulateArtistsAndAlbumFilters(tracks);

                this.ClearStatus();
                this.HideProgressBar();
                this.SetBusyState(false);
            };

            this.dataGridViewTracks.Rows.Clear();
            this.dataGridViewArtists.Rows.Clear();
            this.dataGridViewAlbums.Rows.Clear();

            this.SetBusyState(true);
            this.SetProgressBar(0, numTracks);
            this.SetStatus(Properties.Resources.LoadingCollection);
            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Displays the list of collections
        /// </summary>
        private void DisplayCollectionList()
        {
            if (this.collections.Any())
            {
                this.dataGridViewCollections.Rows.Add("(All)");
                this.dataGridViewCollections.Rows.Add("(Search)");
                addToCollectionToolStripMenuItem.DropDownItems.Add(new ToolStripSeparator());

                foreach (var kvp in this.collections)
                {
                    ToolStripMenuItem item = new ToolStripMenuItem(kvp.Key);
                    item.Click += (sender, e) =>
                    {
                        this.AddTracksToCollection(kvp.Key);
                    };

                    this.dataGridViewCollections.Rows.Add(kvp.Key);
                    this.addToCollectionToolStripMenuItem.DropDownItems.Add(item);
                }
            }
            else
            {
                this.dataGridViewCollections.Rows.Add("(Search)");
            }
        }

        /// <summary>
        /// Loads any playlist import plugins
        /// </summary>
        private void LoadImportPlugins()
        {
            Type pluginType = typeof(IPlaylistImporter);
            var plugins = new List<IPlaylistImporter>();
            foreach (string filename in Directory.GetFiles(".\\Plugins", "*.dll"))
            {
                Assembly currentAssembly = Assembly.LoadFrom(filename);
                foreach (Type type in currentAssembly.GetExportedTypes().Where(t => t.GetInterface(pluginType.FullName) != null))
                {
                    try
                    {
                        IPlaylistImporter plugin = (IPlaylistImporter)Assembly.GetAssembly(pluginType).CreateInstance(
                            typeName: type.FullName,
                            args: null,
                            ignoreCase: false,
                            bindingAttr: BindingFlags.CreateInstance,
                            binder: null,
                            culture: null,
                            activationAttributes: null);

                        plugins.Add(plugin);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(this, ex.ToString(), Properties.Resources.PluginLoadError, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }

            foreach (var plugin in plugins)
            {
                ToolStripItem item = toolStripMenuItemImportPlaylist.DropDownItems.Add(plugin.MenuItem);
                item.Click += (sender, e) =>
                {
                    plugin.MainForm.ShowDialog(this);
                    this.FindNewTracks(plugin);
                };
            }
        }

        /// <summary>
        /// Finds new tracks from the given playlist import plugin
        /// </summary>
        /// <param name="plugin">Playlist import plugin</param>
        private void FindNewTracks(IPlaylistImporter plugin)
        {
            BackgroundWorker bw = new BackgroundWorker()
            {
                WorkerReportsProgress = true,
                WorkerSupportsCancellation = true
            };

            bw.DoWork += (bwSender, bwArgs) =>
            {
                Regex regex = null;
                try
                {
                    regex = new Regex(plugin.ArtistTrackRegex);
                }
                catch (ArgumentException aex)
                {
                    FindNewTracksThreadStatus status = new FindNewTracksThreadStatus()
                    {
                        Message = aex.Message,
                        Status = FindNewTracksStatus.InvalidRegex
                    };

                    bw.ReportProgress(0, status);
                    return;
                }

                // Distinct tracks only
                plugin.Tracks = plugin.Tracks.Distinct().ToList();
                for (int i = 0; !bw.CancellationPending && i < plugin.Tracks.Count; i++)
                {
                    bw.ReportProgress(0, new FindNewTracksThreadStatus() { Counter = i, Maximum = plugin.Tracks.Count });

                    Match match = regex.Match(plugin.Tracks[i]);
                    FindNewTracksThreadStatus status = new FindNewTracksThreadStatus()
                    {
                        Counter = i,
                        Maximum = plugin.Tracks.Count,
                        Message = plugin.Tracks[i],
                        Status = FindNewTracksStatus.AddNewTrack
                    };

                    if (!match.Success)
                    {
                        status.Status = FindNewTracksStatus.ParseError;
                        bw.ReportProgress(0, status);
                        continue;
                    }

                    if (!bw.CancellationPending)
                    {
                        status.ArtistName = match.Groups["ARTIST"].Value.Trim();
                        status.TrackName = match.Groups["TRACK"].Value.Trim();

                        this.GetArtist(status);
                        this.GetTrack(status);

                        bw.ReportProgress(0, status);
                    }
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                FindNewTracksThreadStatus status = bwArgs.UserState as FindNewTracksThreadStatus;

                this.SetStatus(string.Format("Looking up track {0} of {1}...", status.Counter + 1, status.Maximum));
                this.SetProgressBar(status.Counter);

                switch (status.Status)
                {
                    case FindNewTracksStatus.InvalidRegex:
                        if (DialogResult.Cancel == MessageBox.Show(status.Message, "Regex error", MessageBoxButtons.OKCancel, MessageBoxIcon.Error))
                        {
                            bw.CancelAsync();
                        }

                        break;
                    case FindNewTracksStatus.ParseError:
                        if (DialogResult.Cancel == MessageBox.Show(string.Format("Could not parse song information from <{0}>", status.Message), "Parse error", MessageBoxButtons.OKCancel, MessageBoxIcon.Error))
                        {
                            bw.CancelAsync();
                        }

                        break;
                    case FindNewTracksStatus.UnknownArtist:
                    case FindNewTracksStatus.UnknownTrack:
                        unknownTracks.Enqueue(status);
                        break;
                    case FindNewTracksStatus.AddNewTrack:
                        this.AddNewTrack(status);
                        break;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.ClearStatus();
                this.HideProgressBar();
                this.SetBusyState(false);

                if (this.unknownTracks.Any())
                {
                    this.GetUnknownInfo(this.unknownTracks.Dequeue());
                }
                else
                {
                    this.FindNewTracksEnd();
                }
            };

            this.SetBusyState(true);
            this.unknownTracks.Clear();
            this.dataGridViewTracks.Rows.Clear();
            this.SetProgressBar(1, plugin.Tracks.Count);
            bw.RunWorkerAsync(plugin.Tracks);
        }

        /// <summary>
        /// Runs after the user is done finding new tracks
        /// </summary>
        private void FindNewTracksEnd()
        {
            if (this.skippedTracks.Any() &&
                DialogResult.Yes == MessageBox.Show(
                    Properties.Resources.SkippedTracksClipboard,
                    Properties.Resources.SkippedTracksClipboardCaption,
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning))
            {
                Clipboard.SetText(string.Join(Environment.NewLine, this.skippedTracks));
            }

            this.SaveArtistCache();
            this.SaveSearchTrackCache();
            this.SaveMisspelledArtistCache();
            this.SaveMisspelledTrackCache();
            this.SetBusyState(false);
        }

        /// <summary>
        /// Gets missing info when a search query doesn't return an exact match
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownInfo(FindNewTracksThreadStatus unknownTrack)
        {
            if (unknownTrack.Status == FindNewTracksStatus.UnknownArtist)
            {
                this.GetUnknownArtist(unknownTrack);
            }
            else if (unknownTrack.Status == FindNewTracksStatus.UnknownTrack)
            {
                this.GetUnknownTrackThreadSafe(unknownTrack);
            }
        }

        /// <summary>
        /// Gets track information when no exact match is found for the track
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownTrack(FindNewTracksThreadStatus unknownTrack)
        {
            List<SearchTrack> trackList = unknownTrack.Tracks.TrackList;
            var artistQuery = unknownTrack.Tracks.TrackList.Where(t => t.Artist.Href == unknownTrack.ArtistHref);
            if (artistQuery.Any())
            {
                trackList = artistQuery.ToList();
            }

            string originalTrack = unknownTrack.TrackName;
            UnknownTrack ut = new UnknownTrack(unknownTrack.ArtistName, unknownTrack.ArtistHref, unknownTrack.TrackName, trackList);
            if (ut.ShowDialog(this) == DialogResult.Cancel)
            {
                unknownTrack.Status = FindNewTracksStatus.Cancel;
                this.FindNewTracksEnd();
                return;
            }

            if (ut.SelectedTrack != null)
            {
                unknownTrack.Track = ut.SelectedTrack;
                string misspelledKey = string.Format("{0}:::{1}", unknownTrack.ArtistHref, originalTrack);

                if (unknownTrack.Track is Track)
                {
                    Track track = unknownTrack.Track as Track;
                    this.misspelledTracks[misspelledKey] = track.Name;
                    this.cachedLookupTracks.Add(track.Id.Value, track);

                    string path = Path.Combine(Application.UserAppDataPath, "Lookup", "Tracks", track.Href.Replace("spotify:track:", string.Empty) + ".xml");
                    SpotifyService.Serialize(track, path);
                }
                else if (unknownTrack.Track is SearchTrack)
                {
                    XDocument doc = new XDocument();
                    SearchTrack track = unknownTrack.Track as SearchTrack;
                    this.misspelledTracks[misspelledKey] = track.Name;

                    string path = Path.Combine(Application.UserAppDataPath, "Search", unknownTrack.ArtistHref.Replace("spotify:artist:", string.Empty) + ".xml");

                    XElement trackNode = new XElement(
                        "Track",
                        new XAttribute("Query", unknownTrack.TrackName),
                        HttpUtility.HtmlEncode(SpotifyService.Serialize(track)));

                    if (File.Exists(path))
                    {
                        doc = XDocument.Load(path);
                        doc.Root.Add(trackNode);
                    }
                    else
                    {
                        doc = new XDocument(new XElement("Tracks", trackNode));
                    }

                    doc.Save(path);
                }
            }
            else
            {
                unknownTrack.Status = FindNewTracksStatus.TrackSkipped;
                this.skippedTracks.Add(unknownTrack.Message);
            }
        }

        /// <summary>
        /// Gets artist information when no exact match is found for the artist
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownArtist(FindNewTracksThreadStatus unknownTrack)
        {
            if (unknownTrack.ArtistHref == null)
            {
                string originalArtist = unknownTrack.ArtistName;
                UnknownArtist ua = new UnknownArtist(unknownTrack.ArtistName, unknownTrack.Artists);
                if (ua.ShowDialog(this) == DialogResult.Cancel)
                {
                    unknownTrack.Status = FindNewTracksStatus.Cancel;
                    this.FindNewTracksEnd();
                    return;
                }

                if (ua.SelectedArtist != null)
                {
                    unknownTrack.Artist = ua.SelectedArtist;

                    unknownTrack.ArtistName = unknownTrack.Artist.Name;
                    unknownTrack.ArtistHref = unknownTrack.Artist.Href;
                    this.misspelledArtists[originalArtist] = unknownTrack.ArtistName;
                    this.cachedArtistHrefs[unknownTrack.ArtistName] = unknownTrack.Artist.Href;

                    this.GetUnknownTrackThreadSafe(unknownTrack);
                }
                else
                {
                    unknownTrack.Status = FindNewTracksStatus.TrackSkipped;
                    this.skippedTracks.Add(unknownTrack.Message);
                    if (this.unknownTracks.Any())
                    {
                        this.GetUnknownInfo(this.unknownTracks.Dequeue());
                    }
                    else
                    {
                        this.FindNewTracksEnd();
                    }
                }
            }
        }

        /// <summary>
        /// Gets track information
        /// </summary>
        /// <param name="unknownTrack">FindNewTracks thread status</param>
        private void GetUnknownTrackThreadSafe(FindNewTracksThreadStatus unknownTrack)
        {
            BackgroundWorker bw = new BackgroundWorker();

            bw.DoWork += (bwSender, bwArgs) =>
            {
                this.GetTrack(unknownTrack);

                if (unknownTrack.Tracks == null)
                {
                    unknownTrack.Tracks = this.search.Value.SearchTracks(unknownTrack.TrackName);
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (unknownTrack.Status != FindNewTracksStatus.TrackSkipped)
                {
                    this.GetUnknownTrack(unknownTrack);
                }

                if (unknownTrack.Status == FindNewTracksStatus.Cancel)
                {
                    return;
                }

                if (unknownTrack.Status != FindNewTracksStatus.TrackSkipped)
                {
                    this.AddNewTrack(unknownTrack);
                }

                if (this.unknownTracks.Any())
                {
                    this.GetUnknownInfo(this.unknownTracks.Dequeue());
                }
                else
                {
                    this.FindNewTracksEnd();
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Adds a new track to the track gird
        /// </summary>
        /// <param name="status">FindNewTracks thread status</param>
        private void AddNewTrack(FindNewTracksThreadStatus status)
        {
            int trackNumber = 0;
            double popularity = 0, length = 0;
            string trackName = null, artistName = null, albumName = null;

            if (status.Track is SearchTrack)
            {
                SearchTrack track = status.Track as SearchTrack;
                trackName = track.Name;
                artistName = track.Artist.Name;
                albumName = track.Album.Name;
                popularity = track.Popularity.Value;
                length = track.Length.Value;
                trackNumber = track.TrackNumber.Value;
            }
            else if (status.Track is Track)
            {
                Track track = status.Track as Track;
                trackName = track.Name;
                artistName = track.Artist.Name;
                albumName = track.Album.Name;
                popularity = track.Popularity.Value;
                length = track.Length.Value;
                trackNumber = track.TrackNumber.Value;
            }

            DataGridViewRow row = new DataGridViewRow();
            row.CreateCells(this.dataGridViewTracks, null, trackNumber, trackName, artistName, TimeSpan.FromSeconds((double)length).ToString(@"m\:ss"), this.GetPopularityImage(popularity), albumName);
            row.Cells[(int)TrackColumns.Popularity].Tag = popularity;
            row.Cells[(int)TrackColumns.Time].Tag = length;
            row.Tag = status.Track;

            this.dataGridViewTracks.Rows.Add(row);
        }

        /// <summary>
        /// Gets the Spotify artist
        /// </summary>
        /// <param name="status">Thread status object</param>
        private void GetArtist(FindNewTracksThreadStatus status)
        {
            string artistName = status.ArtistName;
            bool artistFound = this.cachedArtistHrefs.ContainsKey(artistName);

            if (!artistFound && this.misspelledArtists.ContainsKey(artistName))
            {
                artistName = this.misspelledArtists[artistName];
                artistFound = this.cachedArtistHrefs.ContainsKey(artistName);
            }

            if (artistFound)
            {
                status.ArtistHref = this.cachedArtistHrefs[artistName];
            }
            else
            {
                status.Artists = this.search.Value.SearchArtists(artistName);
                var artistQuery = status.Artists.ArtistList.Where(a => a.Name.Equals(artistName, System.StringComparison.OrdinalIgnoreCase));
                if (!artistQuery.Any())
                {
                    status.Status = FindNewTracksStatus.UnknownArtist;
                }
                else
                {
                    status.Artist = artistQuery.First();
                }

                if (status.Artist != null)
                {
                    this.cachedArtistHrefs[artistName] = status.Artist.Href;
                    status.ArtistName = status.Artist.Name;
                    status.ArtistHref = status.Artist.Href;
                }
            }
        }

        /// <summary>
        /// Gets the Spotify track
        /// </summary>
        /// <param name="status">Thread status object</param>
        private void GetTrack(FindNewTracksThreadStatus status)
        {
            if (status.ArtistHref == null)
            {
                return;
            }

            SearchTrack track = null;
            string trackName = status.TrackName;
            string key = string.Format("{0}:::{1}", status.ArtistHref, trackName);

            bool trackFound = this.cachedSearchTracks.ContainsKey(key);
            if (!trackFound && this.misspelledTracks.ContainsKey(key))
            {
                trackName = this.misspelledTracks[key];
                key = string.Format("{0}:::{1}", status.ArtistHref, trackName);
                trackFound = this.cachedSearchTracks.ContainsKey(key);
            }

            if (trackFound && (track = this.cachedSearchTracks[key]) != null)
            {
                status.Track = track;
            }
            else
            {
                XDocument doc = null;
                string path = Path.Combine(Application.UserAppDataPath, "Search", status.ArtistHref.Replace("spotify:artist:", string.Empty) + ".xml");
                if (File.Exists(path))
                {
                    doc = XDocument.Load(path);
                    var trackNode = from node in doc.Root.Elements("Track")
                                    where node.Attribute("Query").Value.Equals(trackName, StringComparison.OrdinalIgnoreCase)
                                    select node;

                    if (trackNode.Any())
                    {
                        track = SpotifyService.Deserialize<SearchTrack>(HttpUtility.HtmlDecode(trackNode.First().Value));
                        status.Track = track;
                        this.cachedSearchTracks[key] = track;
                        return;
                    }
                }

                status.Tracks = this.search.Value.SearchTracks(trackName);
                var trackQuery = status.Tracks.TrackList.Where(t => t.Artist.Href == status.ArtistHref && t.Name.Equals(trackName, StringComparison.OrdinalIgnoreCase));

                if (!trackQuery.Any())
                {
                    status.Status = FindNewTracksStatus.UnknownTrack;
                }
                else
                {
                    track = trackQuery.First();
                }

                if (track != null)
                {
                    status.Track = track;
                    this.cachedSearchTracks[key] = track;

                    XElement trackNode = new XElement(
                        "Track",
                        new XAttribute("Query", trackName),
                        HttpUtility.HtmlEncode(SpotifyService.Serialize(track)));

                    if (File.Exists(path))
                    {
                        doc.Root.Add(trackNode);
                    }
                    else
                    {
                        doc = new XDocument(new XElement("Tracks", trackNode));
                    }

                    doc.Save(path);
                }
            }
        }

        /// <summary>
        /// Clears the current status
        /// </summary>
        private void ClearStatus()
        {
            this.SetStatus(string.Empty);
        }

        /// <summary>
        /// Sets the status to busy
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusBusy(string message)
        {
            this.SetStatus(message);
            this.SetBusyState(true);
        }

        /// <summary>
        /// Sets the status after an error
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusError(string message)
        {
            this.SetStatus(message, Color.DarkRed);
            this.SetBusyState(false);
        }

        /// <summary>
        /// Sets the status after a successful event
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusSuccess(string message)
        {
            this.SetStatus(message);
            this.SetBusyState(false);
        }

        /// <summary>
        /// Sets the status
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatus(string message)
        {
            this.SetStatus(message, Color.FromKnownColor(KnownColor.ControlText));
        }

        /// <summary>
        /// Sets the status
        /// </summary>
        /// <param name="message">Message to set</param>
        /// <param name="color">Message color to use</param>
        private void SetStatus(string message, Color color)
        {
            labelStatus.Text = message;
            labelStatus.ForeColor = color;
        }

        /// <summary>
        /// Sets busy state
        /// </summary>
        /// <param name="busy">True to use wait cursor</param>
        private void SetBusyState(bool busy)
        {
            Cursor.Current = busy ? Cursors.WaitCursor : Cursors.Default;
            this.Cursor = busy ? Cursors.WaitCursor : Cursors.Default;
            dataGridViewTracks.Cursor = busy ? Cursors.WaitCursor : Cursors.Default; // hack?
            this.UseWaitCursor = busy;
            Application.UseWaitCursor = busy;
        }

        /// <summary>
        /// Saves the artist cache
        /// </summary>
        private void SaveArtistCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.cachedArtistHrefs.Select(kvp => string.Format("{0}|||{1}", kvp.Key, kvp.Value)).ToArray());
            Properties.Settings.Default.CachedArtistHrefs = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Saves the misspelled artist cache
        /// </summary>
        private void SaveMisspelledArtistCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.misspelledArtists.Select(kvp => string.Format("{0}|||{1}", kvp.Key, kvp.Value)).ToArray());
            Properties.Settings.Default.CachedMisspelledArtists = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Saves the misspelled track cache
        /// </summary>
        private void SaveMisspelledTrackCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.misspelledTracks.Select(kvp => string.Format("{0}|||{1}", kvp.Key, kvp.Value)).ToArray());
            Properties.Settings.Default.CachedMisspelledTracks = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Reads the artist href cache
        /// </summary>
        private void ReadArtistCache()
        {
            foreach (string cachedArtistHrefLine in Properties.Settings.Default.CachedArtistHrefs)
            {
                string[] split = cachedArtistHrefLine.Split(new string[] { "|||" }, StringSplitOptions.None);
                this.cachedArtistHrefs[split[0]] = split[1];
            }
        }

        /// <summary>
        /// Reads the cached list of misspelled artists
        /// </summary>
        private void ReadMisspelledArtistCache()
        {
            foreach (string artist in Properties.Settings.Default.CachedMisspelledArtists)
            {
                string[] split = artist.Split(new string[] { "|||" }, StringSplitOptions.None);
                this.misspelledArtists[split[0]] = split[1];
            }
        }

        /// <summary>
        /// Reads the cached list of misspelled tracks
        /// </summary>
        private void ReadMisspelledTrackCache()
        {
            foreach (string track in Properties.Settings.Default.CachedMisspelledTracks)
            {
                string[] split = track.Split(new string[] { "|||" }, StringSplitOptions.None);
                this.misspelledTracks[split[0]] = split[1];
            }
        }

        /// <summary>
        /// Reads the track cache
        /// </summary>
        private void ReadCachedTracks()
        {
            foreach (string cachedTrackUrlLine in Properties.Settings.Default.CachedSearchTracks)
            {
                this.cachedSearchTracks.Add(cachedTrackUrlLine, null);
            }
        }

        /// <summary>
        /// Reads the collections
        /// </summary>
        private void ReadCollections()
        {
            foreach (string collections in Properties.Settings.Default.Collections)
            {
                string[] split = collections.Split(new string[] { "|||" }, StringSplitOptions.None);
                this.collections.Add(split[0], new HashSet<string>(split[1].Split(',').ToList()));
            }
        }

        /// <summary>
        /// Saves the track cache
        /// </summary>
        private void SaveSearchTrackCache()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.cachedSearchTracks.Select(kvp => kvp.Key).ToArray());
            Properties.Settings.Default.CachedSearchTracks = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// Saves the collections
        /// </summary>
        private void SaveCollections()
        {
            StringCollection sc = new StringCollection();
            sc.AddRange(this.collections.Select(kvp => string.Format("{0}|||{1}", kvp.Key, string.Join(",", kvp.Value))).ToArray());
            Properties.Settings.Default.Collections = sc;
            Properties.Settings.Default.Save();
        }

        /// <summary>
        /// SpotConForm FormClosed event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_FormClosed(object sender, FormClosedEventArgs e)
        {
            if (this.listener != null)
            {
                this.listener.Close();
            }

            foreach (Socket worker in this.workers.Values)
            {
                if (worker != null)
                {
                    worker.Close();
                }
            }

            foreach (var item in this.hostData.Values)
            {
                if (item != null && item.Socket != null)
                {
                    item.Socket.Close();
                }
            }
        }

        /// <summary>
        /// toolStripButtonPrevious Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripButtonPrevious_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Previous");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// toolStripButtonPlayPause Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripButtonPlayPause_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Pause");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// toolStripButtonNext Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripButtonNext_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Next");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        private void SendToServer(string command)
        {
            this.SendToServer(command, this.selectedHost, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="server">Destination server</param>
        private void SendToServer(string command, string server)
        {
            this.SendToServer(command, server, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="server">Destination server</param>
        /// <param name="client">Client name</param>
        private void SendToServer(string command, string server, string client)
        {
            try
            {
                if (this.hostData.ContainsKey(server) && this.hostData[server].Socket != null && this.hostData[server].Socket.Connected)
                {
                    lock (this.sendLock)
                    {
                        byte[] bytes = Encoding.ASCII.GetBytes(client + "|" + command);
                        this.hostData[server].Socket.Send(bytes);
                    }
                }
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        private void SendToClient(string command)
        {
            this.SendToClient(command, this.selectedHost, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="client">Destination client</param>
        private void SendToClient(string command, string client)
        {
            this.SendToClient(command, client, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="client">Destination client</param>
        /// <param name="server">Server name</param>
        private void SendToClient(string command, string client, string server)
        {
            try
            {
                if (this.workers.ContainsKey(client) && this.workers[client].Connected)
                {
                    lock (this.sendLock)
                    {
                        byte[] bytes = Encoding.ASCII.GetBytes(server + "|" + command);
                        this.workers[client].Send(bytes);
                    }
                }
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// dataGridViewComputers CellValueChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_CellValueChanged(object sender, DataGridViewCellEventArgs e)
        {
            if (e.ColumnIndex != (int)HostColumns.Checkbox || e.RowIndex < 0)
            {
                return;
            }

            bool isChecked = (bool)dataGridViewComputers[e.ColumnIndex, e.RowIndex].Value;
            string host = dataGridViewComputers[(int)HostColumns.Name, e.RowIndex].Value.ToString();

            if (!isChecked)
            {
                if (this.hostData.ContainsKey(host) && this.hostData[host] != null && this.hostData[host].Socket != null && this.hostData[host].Socket.Connected)
                {
                    this.hostData[host].Timer.Stop();
                    this.hostData[host].Socket.Close();
                    this.hostData[host].ConnectionStatus = ClientConnectStatus.Disconnected;
                    dataGridViewComputers[(int)HostColumns.ConnectionStatus, e.RowIndex].Value = this.hostImages.Images[(int)ClientConnectStatus.Disconnected];
                    this.SetStatus(string.Format(Properties.Resources.DisconnectedFrom, host));
                }
            }
            else
            {
                this.ConnectToServer(e.ColumnIndex, e.RowIndex, host);
            }
        }

        /// <summary>
        /// Connects to the server
        /// </summary>
        /// <param name="colIndex">Column index of host data grid</param>
        /// <param name="rowIndex">Row index of host data grid</param>
        /// <param name="server">Server to which to connect</param>
        private void ConnectToServer(int colIndex, int rowIndex, string server)
        {
            dataGridViewComputers.Enabled = false;
            BackgroundWorker bw = new BackgroundWorker() { WorkerReportsProgress = true };
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (!this.hostData.ContainsKey(server) || this.hostData[server] == null)
                {
                    bwArgs.Result = false;
                }
                else
                {
                    try
                    {
                        Socket socket = this.hostData[server].Socket != null &&
                                        this.hostData[server].Socket.Connected ? this.hostData[server].Socket : new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                        IPEndPoint remoteEndPoint = new IPEndPoint(this.hostData[server].IPAddress, Port);
                        IAsyncResult result = socket.BeginConnect(remoteEP: remoteEndPoint, callback: null, state: null);

                        if (server != this.currentHost)
                        {
                            bw.ReportProgress(0, string.Format(Properties.Resources.ConnectingToClient, server));
                        }

                        bool success = result.AsyncWaitHandle.WaitOne(millisecondsTimeout: 3000, exitContext: true);
                        if (success)
                        {
                            this.hostData[server].Socket = socket;
                            this.hostData[server].ConnectionStatus = socket.Connected ? ClientConnectStatus.Connected : ClientConnectStatus.ConnectionFailure;

                            if (socket.Connected)
                            {
                                this.SendToServer("|Connected");
                            }
                        }
                        else
                        {
                            socket.Close();
                            this.hostData[server].ConnectionStatus = ClientConnectStatus.ConnectionFailure;
                        }

                        bwArgs.Result = success;
                    }
                    catch (Exception ex)
                    {
                        bwArgs.Result = ex;
                    }
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                this.SetStatusBusy(bwArgs.UserState as string);
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                dataGridViewComputers.Enabled = true;

                if (bwArgs.Result is Exception)
                {
                    Exception ex = bwArgs.Result as Exception;
                    this.SetStatusError(ex.Message);
                }
                else if (bwArgs.Result is bool)
                {
                    bool success = (bool)bwArgs.Result;
                    ClientConnectStatus status = this.hostData[server] == null ? ClientConnectStatus.ConnectionFailure : this.hostData[server].ConnectionStatus;
                    dataGridViewComputers[(int)HostColumns.ConnectionStatus, rowIndex].Value = hostImages.Images[(int)status];
                    switch (status)
                    {
                        case ClientConnectStatus.Connected:
                            if (server != this.currentHost)
                            {
                                this.SetStatusSuccess(string.Format(Properties.Resources.ConnectingToClientSuccess, server));
                            }

                            dataGridViewComputers.Rows[rowIndex].Selected = true;

                            Timer timer = null;
                            if (this.hostData[server].Timer == null)
                            {
                                timer = new Timer() { Interval = this.defaultWaitTime, Enabled = true };
                                timer.Tick += (sender, e) =>
                                {
                                    BackgroundWorker bw2 = new BackgroundWorker();
                                    bw2.DoWork += (bw2Sender, bw2Args) =>
                                    {
                                        this.SendToServer("|GetStatusFromServer", server);
                                    };

                                    bw2.RunWorkerAsync();
                                };

                                this.hostData[server].Timer = timer;
                            }
                            else
                            {
                                timer = this.hostData[server].Timer;
                            }

                            foreach (var ip in this.hostData.Values.Where(i => i != null && i.Timer != null && i.Timer.Enabled))
                            {
                                ip.Timer.Stop();
                            }

                            timer.Start();
                            break;

                        case ClientConnectStatus.ConnectionFailure:
                            this.SetStatusError(string.Format(success ? Properties.Resources.ConnectingToClientUnknown : Properties.Resources.ConnectingToClientError, server));
                            dataGridViewComputers[colIndex, rowIndex].Value = false;
                            break;

                        case ClientConnectStatus.Disconnected:
                            this.ClearStatus();
                            break;
                    }

                    if (success && this.hostData[server].Socket.Connected)
                    {
                        this.WaitForDataClient(this.hostData[server].Socket);
                    }
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// dataGridViewComputers SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_SelectionChanged(object sender, EventArgs e)
        {
            if (dataGridViewComputers.SelectedRows.Count == 0)
            {
                return;
            }

            this.selectedHost = dataGridViewComputers.SelectedRows[0].Cells[(int)HostColumns.Name].Value.ToString();

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (this.hostData[this.selectedHost] == null)
                {
                    this.hostData[this.selectedHost] = new HostData() { IPAddress = Dns.GetHostAddresses(this.selectedHost).FirstOrDefault(i => i.AddressFamily == AddressFamily.InterNetwork) };
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                int selectedRowIndex = dataGridViewComputers.SelectedRows[0].Index;
                for (int i = 0; i < dataGridViewComputers.Rows.Count; i++)
                {
                    DataGridViewCellStyle style = dataGridViewComputers.Rows[i].InheritedStyle;
                    style.Font = new Font(style.Font, i == selectedRowIndex ? FontStyle.Bold : FontStyle.Regular);
                    dataGridViewComputers.Rows[i].DefaultCellStyle = style;
                }

                foreach (var ip in this.hostData.Values.Where(i => i != null && i.Timer != null && i.Timer.Enabled))
                {
                    ip.Timer.Stop();
                }

                if (this.hostData[this.selectedHost] != null && this.hostData[this.selectedHost].Timer != null)
                {
                    this.hostData[this.selectedHost].Timer.Start();
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// dataGridViewComputers CurrentCellDirtyStateChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_CurrentCellDirtyStateChanged(object sender, EventArgs e)
        {
            if (dataGridViewComputers.IsCurrentCellDirty)
            {
                dataGridViewComputers.CommitEdit(DataGridViewDataErrorContexts.Commit);
            }
        }

        /// <summary>
        /// Updates the status
        /// </summary>
        /// <param name="status">Status to update</param>
        /// <returns>True if success</returns>
        private bool UpdateStatus(Responses.Status status)
        {
            if (status == null || status.OpenGraphState == null || status.OpenGraphState.PrivateSession)
            {
                this.SetStatusError(Properties.Resources.PrivateSessionError);
                return false;
            }

            if (status.Error != null)
            {
                this.SetStatusError(string.Format(Properties.Resources.StatusError, status.Error.Type));
                return false;
            }

            if (status.Track == null)
            {
                this.SetStatusError(string.Format(Properties.Resources.StatusError, string.Empty));
                return false;
            }

            if (this.linkLabelArtist.Text != status.Track.ArtistResource.Name)
            {
                this.linkLabelArtist.Text = status.Track.ArtistResource.Name;
                this.linkLabelArtist.Tag = status.Track.ArtistResource.Uri;
                this.linkLabelArtist.Enabled = true;
            }

            if (this.linkLabelTrack.Text != status.Track.TrackResource.Name)
            {
                this.linkLabelTrack.Text = status.Track.TrackResource.Name;
                this.linkLabelTrack.Tag = status.Track.TrackResource.Uri;
                this.linkLabelTrack.Enabled = true;
            }

            if (!panelPlayPause.Capture)
            {
                if (status.Playing)
                {
                    this.panelPlayPause.BackgroundImage = Properties.Resources.Pause;
                }
                else
                {
                    this.panelPlayPause.BackgroundImage = Properties.Resources.Play;
                }

                if (status.IsPlayEnabled)
                {
                    this.panelPlayPause.Enabled = true;
                }
                else
                {
                    this.panelPlayPause.Enabled = false;
                    this.panelPlayPause.BackgroundImage = Properties.Resources.PlayDisabled;
                }
            }

            if (!this.panelPrevious.Capture)
            {
                if (status.IsPrevEnabled)
                {
                    this.panelPrevious.Enabled = true;
                }
                else
                {
                    this.panelPrevious.Enabled = false;
                    this.panelPrevious.BackgroundImage = Properties.Resources.PreviousDisabled;
                }
            }

            if (!this.panelNext.Capture)
            {
                this.panelNext.Enabled = true;
            }

            if (!this.panelVolumeKnob.Capture)
            {
                this.panelVolumeKnob.Left = (int)((this.panelVolume.Width - this.panelVolumeKnob.Width) * status.Volume / 1.0);
            }

            string position = TimeSpan.FromSeconds(status.PlayingPosition).ToString(@"m\:ss");
            string end = TimeSpan.FromSeconds((double)status.Track.Length).ToString(@"m\:ss");
            this.labelTime.Text = string.Format("{0}/{1}", position, end);

            this.panelShuffle.BackgroundImage = status.Shuffle ? Properties.Resources.ShuffleGreen : Properties.Resources.Shuffle;
            this.panelRepeat.BackgroundImage = status.Repeat ? Properties.Resources.RepeatGreen : Properties.Resources.Repeat;

            return true;
        }

        /// <summary>
        /// Adds an action to the history queue
        /// </summary>
        /// <param name="action">Action to add</param>
        private void AddHistoryAction(Action action)
        {
            this.history.RemoveRange(this.historyIndex + 1, this.history.Count - this.historyIndex - 1);
            this.history.Add(action);
            this.historyIndex++;

            if (this.history.Count > 1)
            {
                this.panelBack.Tag = true;
                this.panelBack.BackgroundImage = Properties.Resources.Back;
            }

            if (this.historyIndex == this.history.Count - 1)
            {
                this.panelForward.Tag = false;
                this.panelForward.BackgroundImage = Properties.Resources.ForwardDisabled;
            }
        }

        /// <summary>
        /// Lookups the given album
        /// </summary>
        /// <param name="query">Album href</param>
        /// <param name="selectedTrackHref">Href of track to select</param>
        /// <param name="friendlyName">The query to display in the status bar</param>
        /// <param name="fromHistory">Indicates whether the method is being invoked from the history</param>
        private void LookupAlbum(string query, string selectedTrackHref, string friendlyName, bool fromHistory = false)
        {
            if (string.IsNullOrEmpty(query))
            {
                return;
            }

            if (!fromHistory)
            {
                string queryCopy = string.Copy(query);
                string selectedTrackHrefCopy = string.Copy(selectedTrackHref);
                this.AddHistoryAction(() => this.LookupAlbum(queryCopy, selectedTrackHrefCopy, friendlyName, fromHistory: true));
            }

            this.SetStatus(string.Format(Properties.Resources.Searching, friendlyName));
            this.dataGridViewTracks.Rows.Clear();
            this.dataGridViewArtists.Rows.Clear();
            this.dataGridViewAlbums.Rows.Clear();
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                query = query.Split(':')[2];

                Album album = null;
                string albumPath = Path.Combine(Application.UserAppDataPath, "Lookup", "Albums", query + ".xml");
                if (this.cachedLookupAlbums.ContainsKey(query))
                {
                    album = this.cachedLookupAlbums[query];
                }
                else if (File.Exists(albumPath))
                {
                    album = SpotifyService.Deserialize<Album>(File.ReadAllText(albumPath));
                }
                else
                {
                    album = lookup.Value.LookupAlbum(query, LookupService.AlbumExtras.TrackDetail);
                    SpotifyService.Serialize(album, albumPath);
                }

                album.Href = "spotify:album:" + query;
                bwArgs.Result = album;
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                Album album = bwArgs.Result as Album;
                this.SetStatus(string.Format(Properties.Resources.DisplayResults, album.Tracks.Count, album.Tracks.Count == 1 ? string.Empty : "s", friendlyName));
                album.Tracks.ForEach(t =>
                {
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewTracks, null, t.TrackNumber, t.Name, t.Artist.Name, TimeSpan.FromSeconds((double)t.Length.Value).ToString(@"m\:ss"), this.GetPopularityImage(t.Popularity), album.Name);
                    row.Cells[(int)TrackColumns.Popularity].Tag = t.Popularity;
                    row.Cells[(int)TrackColumns.Time].Tag = t.Length.Value;
                    row.Tag = new Tuple<ArtistTrack, Album>(t, album);

                    this.dataGridViewTracks.Rows.Add(row);
                    row.Selected = t.Href == selectedTrackHref;
                });

                this.PopulateArtistsAndAlbumFilters(album);
                this.SortTracklist((int)TrackColumns.TrackNumber, SortOrder.Ascending);
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Searches the Spootify database
        /// </summary>
        /// <param name="query">Query to search</param>
        /// <param name="searchType">Type of search. Used in filtering the results</param>
        /// <param name="fromHistory">Indicates whether the method is being invoked from the history</param>
        private void Search(string query, SearchType? searchType = null, bool fromHistory = false)
        {
            if (string.IsNullOrEmpty(query))
            {
                return;
            }

            Action action = null;
            if (query.StartsWith("spotify:"))
            {
                action = new Action(() => this.SendToServer(query + "|Play"));
            }
            else if (query.StartsWith("http://open.spotify.com"))
            {
                action = new Action(() => this.SendToServer(query + "|Play"));
            }
            else
            {
                if (!fromHistory)
                {
                    this.AddHistoryAction(() => this.Search(query, searchType, fromHistory: true));
                }

                this.dataGridViewTracks.Rows.Clear();
                this.dataGridViewArtists.Rows.Clear();
                this.dataGridViewAlbums.Rows.Clear();
                this.SetStatusBusy(string.Format(Properties.Resources.Searching, query));
            }

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (action != null)
                {
                    action.Invoke();
                }
                else
                {
                    List<SearchTrack> tracks = search.Value.SearchTracks(query).TrackList;
                    if (searchType.HasValue)
                    {
                        switch (searchType.Value)
                        {
                            case SearchType.Album:
                                tracks = tracks.Where(t => t.Album.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                            case SearchType.Artist:
                                tracks = tracks.Where(t => t.Artist.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                            case SearchType.Track:
                                tracks = tracks.Where(t => t.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                        }
                    }

                    bwArgs.Result = tracks;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (bwArgs.Result is List<SearchTrack>)
                {
                    List<SearchTrack> tracks = bwArgs.Result as List<SearchTrack>;

                    tracks.ForEach(t =>
                    {
                        DataGridViewRow row = new DataGridViewRow();
                        row.CreateCells(this.dataGridViewTracks, null, t.TrackNumber, t.Name, t.Artist.Name, TimeSpan.FromSeconds((double)t.Length.Value).ToString(@"m\:ss"), this.GetPopularityImage(t.Popularity), t.Album.Name);
                        row.Cells[(int)TrackColumns.Popularity].Tag = t.Popularity;
                        row.Cells[(int)TrackColumns.Time].Tag = t.Length.Value;
                        row.Tag = t;

                        this.dataGridViewTracks.Rows.Add(row);
                    });

                    this.PopulateArtistsAndAlbumFilters(tracks);

                    if (this.dataGridViewCollections.Rows.Count > 1)
                    {
                        this.dataGridViewCollections.Tag = false;
                        foreach (DataGridViewRow row in this.dataGridViewCollections.Rows)
                        {
                            row.Selected = false;
                        }

                        this.dataGridViewCollections.Rows[1].Selected = true;
                        this.dataGridViewCollections.Tag = true;
                    }

                    this.SetBusyState(false);
                    this.SetStatus(string.Format(Properties.Resources.DisplayResults, tracks.Count, tracks.Count == 1 ? string.Empty : "s", query));
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Popualates the artists and album filter data grids
        /// </summary>
        /// <param name="tracks">Track information</param>
        private void PopulateArtistsAndAlbumFilters(List<SearchTrack> tracks)
        {
            var distinctArtists = from t in tracks
                                  orderby t.Artist.Name
                                  group t by t.Artist.Href into T
                                  select T;

            if (distinctArtists.Count() > 0)
            {
                this.dataGridViewArtists.Rows.Add(string.Format("All ({0} artist{1})", distinctArtists.Count(), distinctArtists.Count() == 1 ? string.Empty : "s"));
                foreach (var distinctArtist in distinctArtists)
                {
                    SearchTrack track = distinctArtist.First();
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewArtists, track.Artist.Name);
                    row.Tag = track;
                    this.dataGridViewArtists.Rows.Add(row);
                }
            }

            var distinctAlbums = from t in tracks
                                 orderby t.Album.Name
                                 group t by t.Album.Href into T
                                 select T;

            if (distinctAlbums.Count() > 0)
            {
                this.dataGridViewAlbums.Rows.Add(string.Format("All ({0} album{1})", distinctAlbums.Count(), distinctAlbums.Count() == 1 ? string.Empty : "s"));
                foreach (var distinctAlbum in distinctAlbums)
                {
                    SearchTrack track = distinctAlbum.First();
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewAlbums, track.Album.Name, track.Album.Released);
                    row.Tag = distinctAlbum.ToList();
                    this.dataGridViewAlbums.Rows.Add(row);
                }
            }
        }

        /// <summary>
        /// Popualates the artists and album filter data grids
        /// </summary>
        /// <param name="tracks">Track information</param>
        private void PopulateArtistsAndAlbumFilters(List<Track> tracks)
        {
            var distinctArtists = from t in tracks
                                  orderby t.Artist.Name
                                  group t by t.Artist.Href into T
                                  select T;

            if (distinctArtists.Count() > 0)
            {
                int index = this.dataGridViewArtists.Rows.Add(string.Format("All ({0} artist{1})", distinctArtists.Count(), distinctArtists.Count() == 1 ? string.Empty : "s"));
                foreach (var distinctArtist in distinctArtists)
                {
                    Track track = distinctArtist.First();
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewArtists, track.Artist.Name);
                    row.Tag = track;
                    this.dataGridViewArtists.Rows.Add(row);
                }
            }

            var distinctAlbums = from t in tracks
                                 orderby t.Album.Name
                                 group t by t.Album.Href into T
                                 select T;

            if (distinctAlbums.Count() > 0)
            {
                int count = 0;
                this.dataGridViewAlbums.Rows.Add(string.Format("All ({0} album{1})", distinctAlbums.Count(), distinctAlbums.Count() == 1 ? string.Empty : "s"));
                foreach (var distinctAlbum in distinctAlbums)
                {
                    Track track = distinctAlbum.First();
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewAlbums, track.Album.Name, track.Album.Released);
                    row.Tag = distinctAlbum.ToList();
                    row.DefaultCellStyle = ++count % 2 == 0 ? this.dataGridViewAlbums.DefaultCellStyle : this.alternateStyle;
                    this.dataGridViewAlbums.Rows.Add(row);
                }
            }
        }

        /// <summary>
        /// Popualates the artists and album filter data grids
        /// </summary>
        /// <param name="album">Album information</param>
        private void PopulateArtistsAndAlbumFilters(Album album)
        {
            var distinctArtists = from t in album.Tracks
                                  orderby t.Artist.Name
                                  group t by t.Artist.Href into T
                                  select T;

            int count = 0;
            DataGridViewRow row = null;
            this.dataGridViewArtists.Rows.Add(string.Format("All ({0} artist{1})", distinctArtists.Count(), distinctArtists.Count() == 1 ? string.Empty : "s"));
            foreach (var distinctArtist in distinctArtists)
            {
                ArtistTrack track = distinctArtist.First();
                row = new DataGridViewRow();
                row.CreateCells(this.dataGridViewArtists, track.Artist.Name);
                row.Tag = track;
                this.dataGridViewArtists.Rows.Add(row);
                row.DefaultCellStyle = count++ == 0 ? this.dataGridViewArtists.DefaultCellStyle : this.alternateStyle;
            }

            this.dataGridViewAlbums.Rows.Add("All (1 album)");

            row = new DataGridViewRow();
            row.CreateCells(this.dataGridViewAlbums, album.Name, album.Released);
            row.Tag = album;
            this.dataGridViewAlbums.Rows.Add(row);
        }

        /// <summary>
        /// Gets the popularity image
        /// </summary>
        /// <param name="popularity">Track popularity value</param>
        /// <param name="selected">True if the row is selected</param>
        /// <returns>Desired popularity image</returns>
        private Image GetPopularityImage(double? popularity, bool selected = false)
        {
            ImageList imageList = selected ? this.popSelectedImages : this.popImages;
            int numImages = imageList.Images.Count - 1;
            int index = popularity.HasValue ? (int)((double)numImages * popularity) : 0;
            return imageList.Images[index];
        }

        /// <summary>
        /// dataGridViewTracks CellDoubleClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex < 0)
            {
                return;
            }

            string track = this.GetTrackHrefFromTag(this.dataGridViewTracks.Rows[e.RowIndex].Tag);
            this.SendToServer(track + "|Play");
        }

        /// <summary>
        /// Gets the track href from the given track tag
        /// </summary>
        /// <param name="tag">Track tag</param>
        /// <returns>Track href</returns>
        private string GetTrackHrefFromTag(object tag)
        {
            string href = string.Empty;
            if (tag is SearchTrack)
            {
                href = ((SearchTrack)tag).Href;
            }
            else if (tag is Tuple<ArtistTrack, Album>)
            {
                href = ((Tuple<ArtistTrack, Album>)tag).Item1.Href;
            }
            else if (tag is Track)
            {
                href = ((Track)tag).Href;
            }

            return href;
        }

        /// <summary>
        /// Gets the album uri for the given track tag
        /// </summary>
        /// <param name="tag">Track tag</param>
        /// <returns>Album uri</returns>
        private string GetAlbumUriFromTag(object tag)
        {
            string uri = string.Empty;
            if (tag is SearchTrack)
            {
                uri = ((SearchTrack)tag).Album.Href;
            }
            else if (tag is Tuple<ArtistTrack, Album>)
            {
                // This happens when a user clicks the track name
                // It will bring up results for the album and highlight the track
                // Unfortunately, ArtistTrack objects don't contain the URI of the album on which they reside
                // As a result, clicking the name of the album won't do a new search
                // But that's okay because the user would get the exact same results
            }

            return uri;
        }

        /// <summary>
        /// Gets the artist uri from the given track tag
        /// </summary>
        /// <param name="tag">Track tag</param>
        /// <returns>Artist uri</returns>
        private string GetArtistUriFromTag(object tag)
        {
            string uri = string.Empty;
            if (tag is SearchTrack)
            {
                uri = ((SearchTrack)tag).Artist.Href;
            }
            else if (tag is Tuple<ArtistTrack, Album>)
            {
                uri = ((Tuple<ArtistTrack, Album>)tag).Item1.Artist.Href;
            }

            return uri;
        }

        /// <summary>
        /// pictureBox Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void pictureBox_Click(object sender, EventArgs e)
        {
            if (pictureBox.Image != null)
            {
                AlbumArtViewer arv = new AlbumArtViewer(this.currentStatus.Track.AlbumResource.ToString(), pictureBox.Image);
                arv.Show();
            }
        }

        /// <summary>
        /// linkLabelTrack LinkClicked event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelTrack_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            this.LookupAlbum(this.currentStatus.Track.AlbumResource.Uri, this.currentStatus.Track.TrackResource.Uri, this.currentStatus.Track.TrackResource.Name);
        }

        /// <summary>
        /// linkLabelArtist LinkClicked event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelArtist_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            this.Search(linkLabelArtist.Text, SearchType.Artist);
        }

        /// <summary>
        /// dataGridViewTracks SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_SelectionChanged(object sender, EventArgs e)
        {
            if (dataGridViewTracks.SelectedRows.Count == 0)
            {
                return;
            }

            List<int> newSelectedTrackRowIndices = new List<int>();
            for (int i = 0; i < dataGridViewTracks.SelectedRows.Count; i++)
            {
                DataGridViewRow row = dataGridViewTracks.SelectedRows[i];
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).LinkColor = Color.FromKnownColor(KnownColor.HighlightText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).ActiveLinkColor = Color.FromKnownColor(KnownColor.HighlightText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).LinkColor = Color.FromKnownColor(KnownColor.HighlightText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).ActiveLinkColor = Color.FromKnownColor(KnownColor.HighlightText);

                DataGridViewImageCell pop = (DataGridViewImageCell)row.Cells[(int)TrackColumns.Popularity];
                pop.Value = this.GetPopularityImage((double)pop.Tag, selected: true);

                newSelectedTrackRowIndices.Add(row.Index);
            }

            this.selectedTrackRowIndices.RemoveAll(x => newSelectedTrackRowIndices.Contains(x));
            foreach (int i in this.selectedTrackRowIndices)
            {
                if (i < dataGridViewTracks.Rows.Count)
                {
                    DataGridViewRow row = dataGridViewTracks.Rows[i];
                    ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                    ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);
                    ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                    ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);

                    DataGridViewImageCell pop = (DataGridViewImageCell)row.Cells[(int)TrackColumns.Popularity];
                    pop.Value = this.GetPopularityImage((double)pop.Tag, selected: false);
                }
            }

            this.selectedTrackRowIndices = newSelectedTrackRowIndices;
        }

        /// <summary>
        /// dataGridViewTracks RowLeave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_RowLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Artist, e.RowIndex]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Artist, e.RowIndex]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Album, e.RowIndex]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Album, e.RowIndex]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);

                DataGridViewImageCell pop = (DataGridViewImageCell)dataGridViewTracks[(int)TrackColumns.Popularity, e.RowIndex];
                pop.Value = this.GetPopularityImage((double)pop.Tag, selected: false);
            }
        }

        /// <summary>
        /// dataGridViewTracks CellContentClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                if (e.ColumnIndex == (int)TrackColumns.Artist)
                {
                    this.Search(dataGridViewTracks[e.ColumnIndex, e.RowIndex].Value.ToString(), SearchType.Artist);
                }
                else if (e.ColumnIndex == (int)TrackColumns.Album)
                {
                    string uri = this.GetAlbumUriFromTag(this.dataGridViewTracks.Rows[e.RowIndex].Tag);
                    string name = this.dataGridViewTracks[(int)TrackColumns.Track, e.RowIndex].Value.ToString();
                    this.LookupAlbum(uri, this.GetTrackHrefFromTag(this.dataGridViewTracks.Rows[e.RowIndex].Tag), name);
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks SortCompare event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_SortCompare(object sender, DataGridViewSortCompareEventArgs e)
        {
            if (e.Column.Index == (int)TrackColumns.Popularity)
            {
                e.SortResult = Convert.ToInt64(dataGridViewTracks[e.Column.Index, e.RowIndex1].Tag).CompareTo(Convert.ToInt64(dataGridViewTracks[e.Column.Index, e.RowIndex2].Tag));
            }
        }

        /// <summary>
        /// dataGridViewTracks ColumnHeaderMouseClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            this.SortTracklist(e.ColumnIndex);
        }

        /// <summary>
        /// Sorts the track list
        /// </summary>
        /// <param name="column">Column to sort on</param>
        /// <param name="sortOrder">Order of the sort</param>
        private void SortTracklist(int column, SortOrder? sortOrder = null)
        {
            Type type = typeof(string);
            switch (column)
            {
                case (int)TrackColumns.Album:
                case (int)TrackColumns.Artist:
                case (int)TrackColumns.Track:
                    type = typeof(string);
                    break;
                case (int)TrackColumns.Popularity:
                case (int)TrackColumns.Time:
                    type = typeof(double);
                    break;
                case (int)TrackColumns.TrackNumber:
                    type = typeof(int);
                    break;
            }

            // Remove sort glyph from all other headers
            foreach (DataGridViewColumn col in dataGridViewTracks.Columns)
            {
                if (col.Index != column)
                {
                    col.HeaderCell.SortGlyphDirection = System.Windows.Forms.SortOrder.None;
                }
            }

            if (!sortOrder.HasValue)
            {
                sortOrder = dataGridViewTracks.Columns[column].HeaderCell.SortGlyphDirection;
                if ((column == (int)TrackColumns.TrackNumber && sortOrder == SortOrder.None) ||
                    sortOrder == System.Windows.Forms.SortOrder.Descending)
                {
                    sortOrder = System.Windows.Forms.SortOrder.Ascending;
                }
                else
                {
                    sortOrder = System.Windows.Forms.SortOrder.Descending;
                }
            }

            dataGridViewTracks.Sort(new TrackRowComparer(column, sortOrder.Value, type));
            dataGridViewTracks.Columns[column].HeaderCell.SortGlyphDirection = sortOrder.Value;

            int count = 0;
            dataGridViewTracks.AlternatingRowsDefaultCellStyle = null;
            foreach (DataGridViewRow row in this.dataGridViewTracks.Rows)
            {
                if (row.Visible)
                {
                    row.DefaultCellStyle = count++ % 2 == 0 ? dataGridViewTracks.DefaultCellStyle : this.alternateStyle;
                    row.Cells[(int)TrackColumns.Popularity].Style = new DataGridViewCellStyle(row.DefaultCellStyle) { Alignment = DataGridViewContentAlignment.MiddleCenter };
                }
            }
        }

        /// <summary>
        /// linkLabelTrack MouseHover event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelTrack_MouseHover(object sender, EventArgs e)
        {
            this.tooltipTrack.Show(linkLabelTrack.Text, this.linkLabelTrack);
        }

        /// <summary>
        /// linkLabelArtist MouseHover event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelArtist_MouseHover(object sender, EventArgs e)
        {
            this.tooltipArtist.Show(linkLabelArtist.Text, this.linkLabelArtist);
        }

        /// <summary>
        /// panelPlayPause MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelPlayPause.Capture = true;
            if (this.currentStatus.Playing)
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.PausePressed;
            }
            else
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.PlayPressed;
            }
        }

        /// <summary>
        /// panelPlayPause MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelPlayPause.Capture = false;
            if (this.currentStatus.Playing)
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.Pause;
            }
            else
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.Play;
            }
        }

        /// <summary>
        /// panelPrevious MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelPrevious.Capture = true;
            this.panelPrevious.BackgroundImage = Properties.Resources.PreviousPressed;
        }

        /// <summary>
        /// panelPrevious MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelPrevious.Capture = false;
            this.panelPrevious.BackgroundImage = Properties.Resources.Previous;
        }

        /// <summary>
        /// panelNext MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelNext.Capture = true;
            this.panelNext.BackgroundImage = Properties.Resources.NextPressed;
        }

        /// <summary>
        /// panelNext MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelNext.Capture = false;
            this.panelNext.BackgroundImage = Properties.Resources.Next;
        }

        /// <summary>
        /// panelPrevious Click
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Previous");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// panelPlayPause Click
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Pause");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// panelNext Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Next");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// textBoxSearch Enter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_Enter(object sender, EventArgs e)
        {
            this.panelSearch.BackgroundImage = Properties.Resources.SearchFocused;
            if (this.textBoxSearch.Text == "Search")
            {
                this.textBoxSearch.Text = string.Empty;
                this.textBoxSearch.ForeColor = Color.FromKnownColor(KnownColor.WindowText);
            }
        }

        /// <summary>
        /// textBoxSearch Leave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_Leave(object sender, EventArgs e)
        {
            this.panelSearch.BackgroundImage = Properties.Resources.Search;
            if (string.IsNullOrEmpty(this.textBoxSearch.Text))
            {
                this.textBoxSearch.Text = "Search";
                this.textBoxSearch.ForeColor = (Color)this.textBoxSearch.Tag;
            }
        }

        /// <summary>
        /// textBoxSearch KeyDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                this.Search(textBoxSearch.Text);
                e.SuppressKeyPress = true;
                this.ActiveControl = this.panelPlayPause;
            }
        }

        /// <summary>
        /// splitterMain SplitterMoved event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void splitterMain_SplitterMoved(object sender, SplitterEventArgs e)
        {
            this.linkLabelTrack.MaximumSize = new Size(splitterMain.Location.X, this.linkLabelTrack.Height);
            this.linkLabelArtist.MaximumSize = new Size(splitterMain.Location.X, this.linkLabelArtist.Height);
            panelPicture.Height = splitterMain.Location.X;
        }

        /// <summary>
        /// SpotConForm Resize event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_Resize(object sender, EventArgs e)
        {
            this.panelRepeat.Location = new Point(this.Width - 40, this.panelRepeat.Location.Y);
            this.panelShuffle.Location = new Point(this.panelRepeat.Location.X - 1, this.panelShuffle.Location.Y);
        }

        /// <summary>
        /// SpotConForm ResizeBegin event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_ResizeBegin(object sender, EventArgs e)
        {
            this.panelFilter.SuspendLayout();
            this.collectionPercentage = (double)this.dataGridViewCollections.Width / (double)this.dataGridViewTracks.Width;
            this.albumPercentage = (double)this.dataGridViewAlbums.Width / (double)this.dataGridViewTracks.Width;
        }

        /// <summary>
        /// SpotConForm ResizeEnd event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_ResizeEnd(object sender, EventArgs e)
        {
            this.panelFilter.ResumeLayout();
            this.dataGridViewCollections.Width = (int)Math.Round(this.dataGridViewTracks.Width * this.collectionPercentage);
            this.dataGridViewAlbums.Width = (int)Math.Round(this.dataGridViewTracks.Width * this.albumPercentage);
        }

        /// <summary>
        /// SpotConForm SizeChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_SizeChanged(object sender, EventArgs e)
        {
            if (this.WindowState == FormWindowState.Maximized || (this.wasMaximized && this.WindowState == FormWindowState.Normal))
            {
                this.wasMaximized = !this.wasMaximized;
                this.dataGridViewCollections.Width = (int)Math.Round(this.dataGridViewTracks.Width * this.collectionPercentage);
                this.dataGridViewAlbums.Width = (int)Math.Round(this.dataGridViewTracks.Width * this.albumPercentage);
                this.dataGridViewCollections.Visible = this.dataGridViewArtists.Visible = this.dataGridViewAlbums.Visible = true;
            }
        }

        /// <summary>
        /// splitterFilterRight SplitterMoved event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void splitterFilterRight_SplitterMoved(object sender, SplitterEventArgs e)
        {
            this.albumPercentage = (double)this.dataGridViewAlbums.Width / (double)this.dataGridViewTracks.Width;
        }

        /// <summary>
        /// splitterFilterLeft SplitterMoved event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void splitterFilterLeft_SplitterMoved(object sender, SplitterEventArgs e)
        {
            this.collectionPercentage = (double)this.dataGridViewCollections.Width / (double)this.dataGridViewTracks.Width;
        }

        /// <summary>
        /// pictureBox SizeChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void pictureBox_SizeChanged(object sender, EventArgs e)
        {
            this.MinimumSize = new Size(500, Math.Max(410, 410 + panelPicture.Height - 150));
        }

        /// <summary>
        /// panelVolumeKnob MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Tag = e.X;
            this.panelVolumeKnob.Capture = true;
        }

        /// <summary>
        /// panelVolumeKnob MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Capture = false;

            this.ChangeVolume();
        }

        /// <summary>
        /// Changes the volume
        /// </summary>
        private void ChangeVolume()
        {
            double level = (double)this.panelVolumeKnob.Left / (double)(this.panelVolume.Width - this.panelVolumeKnob.Width);
            this.SendToServer(level + ":" + this.currentStatus.Volume + "|SetVolume");
        }

        /// <summary>
        /// panelVolumeKnob MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseMove(object sender, MouseEventArgs e)
        {
            if (this.panelVolumeKnob.Capture)
            {
                this.MoveVolumeKnob(e.X);
            }
        }

        /// <summary>
        /// Moves the volume knob to the given x-coordinate
        /// </summary>
        /// <param name="x">Coordinate to which to move the volume knob</param>
        private void MoveVolumeKnob(int x)
        {
            panelVolumeKnob.Left = Math.Min(Math.Max(0, x + this.panelVolumeKnob.Left - (this.panelVolumeKnob.Width / 2)), this.panelVolume.Width - this.panelVolumeKnob.Width);
        }

        /// <summary>
        /// panelVolume MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolume_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Tag = e.X;
            this.panelVolumeKnob.Capture = true;
            this.MoveVolumeKnob(e.X);
        }

        /// <summary>
        /// panelVolume MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolume_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Capture = false;
            this.ChangeVolume();
        }

        /// <summary>
        /// panelForward MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseMove(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                if (this.panelForward.Bounds.Contains(this.panelForward.Parent.PointToClient(Control.MousePosition)))
                {
                    this.panelForward.Capture = true;
                    this.panelForward.BackgroundImage = Properties.Resources.ForwardHover;
                }
                else
                {
                    this.panelForward.Capture = false;
                    this.panelForward.BackgroundImage = Properties.Resources.Forward;
                }
            }
        }

        /// <summary>
        /// panelBack MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseMove(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                if (panelBack.Bounds.Contains(panelBack.Parent.PointToClient(Control.MousePosition)))
                {
                    this.panelBack.Capture = true;
                    this.panelBack.BackgroundImage = Properties.Resources.BackHover;
                }
                else
                {
                    this.panelBack.Capture = false;
                    this.panelBack.BackgroundImage = Properties.Resources.Back;
                }
            }
        }

        /// <summary>
        /// panelBack MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseDown(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                this.panelBack.BackgroundImage = Properties.Resources.BackClicked;
            }
        }

        /// <summary>
        /// panelForward MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseDown(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                this.panelForward.BackgroundImage = Properties.Resources.ForwardClicked;
            }
        }

        /// <summary>
        /// panelBack MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseUp(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                this.panelBack.BackgroundImage = Properties.Resources.Back;
            }
        }

        /// <summary>
        /// panelForward MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseUp(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                this.panelForward.BackgroundImage = Properties.Resources.Forward;
            }
        }

        /// <summary>
        /// panelBack MouseClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseClick(object sender, MouseEventArgs e)
        {
            this.GoBack();
        }

        /// <summary>
        /// panelForward Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_Click(object sender, EventArgs e)
        {
            this.GoForward();
        }

        /// <summary>
        /// Goes back in the history
        /// </summary>
        private void GoBack()
        {
            if ((bool)this.panelBack.Tag)
            {
                this.history[--this.historyIndex].Invoke();

                this.panelForward.Tag = true;
                this.panelForward.BackgroundImage = Properties.Resources.Forward;

                if (this.historyIndex == 0)
                {
                    this.panelBack.Tag = false;
                    this.panelBack.BackgroundImage = Properties.Resources.BackDisabled;
                }
            }
        }

        /// <summary>
        /// Goes forward in the history
        /// </summary>
        private void GoForward()
        {
            if ((bool)this.panelForward.Tag)
            {
                this.history[++this.historyIndex].Invoke();

                this.panelBack.Tag = true;
                this.panelBack.BackgroundImage = Properties.Resources.Back;

                if (this.historyIndex == this.history.Count - 1)
                {
                    this.panelForward.Tag = false;
                    this.panelForward.BackgroundImage = Properties.Resources.ForwardDisabled;
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks DragEnter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Copy;
        }

        /// <summary>
        /// dataGridViewTracks DragDrop event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_DragDrop(object sender, DragEventArgs e)
        {
            string contents = e.Data.GetData(DataFormats.Text).ToString();
            IEnumerable<string> trackList = contents.Split(Environment.NewLine.ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
            trackList = trackList.Where(l => l.StartsWith("http://open.spotify.com/track/")).Select(l => l.Replace("http://open.spotify.com/track/", string.Empty));

            BackgroundWorker bw = new BackgroundWorker()
            {
                WorkerReportsProgress = true,
                WorkerSupportsCancellation = true
            };

            List<Track> tracks = new List<Track>();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                int i = 0;
                foreach (string href in trackList)
                {
                    if (bw.CancellationPending)
                    {
                        return;
                    }

                    bw.ReportProgress(0, new Tuple<int, int>(++i, trackList.Count()));

                    Track track = null;
                    if (cachedLookupTracks.ContainsKey(href))
                    {
                        track = cachedLookupTracks[href];
                    }
                    else
                    {
                        string path = Path.Combine(Application.UserAppDataPath, "Lookup", "Tracks", href + ".xml");
                        if (File.Exists(path))
                        {
                            track = SpotifyService.Deserialize<Track>(File.ReadAllText(path));
                            track.Href = "spotify:track:" + href;
                        }
                        else
                        {
                            track = lookup.Value.LookupTrack(href);
                            SpotifyService.Serialize(track, path);
                            track.Href = "spotify:track:" + href;
                        }

                        this.cachedLookupTracks[href] = track;
                    }

                    tracks.Add(track);
                    bw.ReportProgress(0, track);
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                if (bwArgs.UserState is Tuple<int, int>)
                {
                    Tuple<int, int> status = bwArgs.UserState as Tuple<int, int>;
                    this.SetStatus(string.Format(Properties.Resources.GatheringTrackInfo, status.Item1, status.Item2));
                    this.SetProgressBar(status.Item1);
                }
                else if (bwArgs.UserState is Track)
                {
                    Track t = bwArgs.UserState as Track;
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewTracks, null, t.TrackNumber, t.Name, t.Artist.Name, TimeSpan.FromSeconds((double)t.Length.Value).ToString(@"m\:ss"), this.GetPopularityImage(t.Popularity), t.Album.Name);
                    row.Cells[(int)TrackColumns.Popularity].Tag = t.Popularity;
                    row.Cells[(int)TrackColumns.Time].Tag = t.Length.Value;
                    row.Tag = t;
                    this.dataGridViewTracks.Rows.Add(row);
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.HideProgressBar();
                this.ClearStatus();
            };

            if (trackList.Any())
            {
                this.dataGridViewTracks.Rows.Clear();
                this.SetProgressBar(0, trackList.Count());
                bw.RunWorkerAsync();
            }
        }

        /// <summary>
        /// dataGridViewCollections SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewCollections_SelectionChanged(object sender, EventArgs e)
        {
            if (this.dataGridViewCollections.Tag != null && !(bool)this.dataGridViewCollections.Tag)
            {
                return;
            }

            if (this.dataGridViewCollections.SelectedRows.Count > 1 && this.dataGridViewCollections.Rows[1].Selected)
            {
                this.dataGridViewCollections.Rows[1].Selected = false;
            }

            if (this.dataGridViewCollections.Rows[0].Selected)
            {
                foreach (DataGridViewRow row in this.dataGridViewCollections.SelectedRows)
                {
                    if (row.Index != 0)
                    {
                        row.Selected = false;
                    }
                }

                this.dataGridViewTracks.Rows.Clear();
                this.DisplayCollectionTracks();
            }
            else
            {
                List<string> selectedColletions = new List<string>();
                foreach (DataGridViewRow row in this.dataGridViewCollections.SelectedRows)
                {
                    selectedColletions.Add(row.Cells[0].Value.ToString());
                }

                this.DisplayCollectionTracks(selectedColletions);
            }
        }

        /// <summary>
        /// dataGridViewArtists SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewArtists_SelectionChanged(object sender, EventArgs e)
        {
            int visibleRows = 0;
            foreach (DataGridViewRow row in this.dataGridViewArtists.Rows)
            {
                if (row.Visible)
                {
                    visibleRows++;
                }
            }

            if (visibleRows == 2)
            {
                // If there's only one artist, switching between "All artists" and the artist will give the same results
                return;
            }

            if (this.dataGridViewArtists.Rows[0].Selected)
            {
                foreach (DataGridViewRow row in this.dataGridViewArtists.SelectedRows)
                {
                    if (row.Index != 0)
                    {
                        row.Selected = false;
                    }
                }

                int count = 0;
                foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
                {
                    row.Visible = true;
                    row.DefaultCellStyle = count++ % 2 == 0 ? dataGridViewAlbums.DefaultCellStyle : this.alternateStyle;
                }

                if (count > 0)
                {
                    // Subtract one for "All albums" row
                    this.dataGridViewAlbums.Rows[0].SetValues(string.Format("All ({0} album{1})", count - 1, count - 1 == 1 ? string.Empty : "s"));
                    this.dataGridViewAlbums.Rows[0].Selected = false;
                    this.dataGridViewAlbums.Rows[0].Selected = true;
                }

                count = 0;
                foreach (DataGridViewRow row in this.dataGridViewTracks.Rows)
                {
                    row.Visible = true;
                    row.DefaultCellStyle = count++ % 2 == 0 ? this.dataGridViewTracks.DefaultCellStyle : this.alternateStyle;
                    row.Cells[(int)TrackColumns.Popularity].Style = new DataGridViewCellStyle(row.DefaultCellStyle) { Alignment = DataGridViewContentAlignment.MiddleCenter };
                }
            }
            else if (this.dataGridViewArtists.SelectedRows.Count > 0)
            {
                List<string> selectedArtistHrefs = new List<string>();
                foreach (DataGridViewRow row in this.dataGridViewArtists.SelectedRows)
                {
                    if (row.Tag is SearchTrack)
                    {
                        selectedArtistHrefs.Add((row.Tag as SearchTrack).Artist.Href);
                    }
                    else if (row.Tag is ArtistTrack)
                    {
                        selectedArtistHrefs.Add((row.Tag as ArtistTrack).Artist.Href);
                    }
                    else if (row.Tag is Track)
                    {
                        selectedArtistHrefs.Add((row.Tag as Track).Artist.Href);
                    }
                }

                int visibleCount = 0;
                this.dataGridViewAlbums.AlternatingRowsDefaultCellStyle = null;
                foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
                {
                    if (row.Index == 0)
                    {
                        continue;
                    }

                    List<string> albumArtistHrefs = null;
                    if (row.Tag is List<SearchTrack>)
                    {
                        List<SearchTrack> albumTracks = row.Tag as List<SearchTrack>;
                        albumArtistHrefs = albumTracks.Select(t => t.Artist.Href).Distinct().ToList();
                    }
                    else if (row.Tag is Album)
                    {
                        Album album = row.Tag as Album;
                        albumArtistHrefs = album.Tracks.Select(t => t.Artist.Href).Distinct().ToList();
                    }
                    else if (row.Tag is List<Track>)
                    {
                        List<Track> tracks = row.Tag as List<Track>;
                        albumArtistHrefs = tracks.Select(t => t.Artist.Href).Distinct().ToList();
                    }

                    if (row.Visible = selectedArtistHrefs.Intersect(albumArtistHrefs).Any())
                    {
                        visibleCount++;
                    }

                    row.DefaultCellStyle = visibleCount % 2 == 0 ? this.dataGridViewAlbums.DefaultCellStyle : this.alternateStyle;
                }

                this.dataGridViewAlbums.Rows[0].SetValues(string.Format("All ({0} album{1})", visibleCount, visibleCount == 1 ? string.Empty : "s"));

                visibleCount = 0;
                this.dataGridViewTracks.AlternatingRowsDefaultCellStyle = null;
                foreach (DataGridViewRow row in this.dataGridViewTracks.Rows)
                {
                    string artistHref = string.Empty;
                    if (row.Tag is SearchTrack)
                    {
                        SearchTrack track = row.Tag as SearchTrack;
                        artistHref = track.Artist.Href;
                    }
                    else if (row.Tag is Track)
                    {
                        Track track = row.Tag as Track;
                        artistHref = track.Artist.Href;
                    }
                    else if (row.Tag is Tuple<ArtistTrack, Album>)
                    {
                        Tuple<ArtistTrack, Album> track = row.Tag as Tuple<ArtistTrack, Album>;
                        artistHref = track.Item1.Artist.Href;
                    }

                    if (row.Visible = selectedArtistHrefs.Contains(artistHref))
                    {
                        visibleCount++;
                    }

                    row.DefaultCellStyle = visibleCount % 2 == 1 ? this.dataGridViewTracks.DefaultCellStyle : this.alternateStyle;
                    row.Cells[(int)TrackColumns.Popularity].Style = new DataGridViewCellStyle(row.DefaultCellStyle) { Alignment = DataGridViewContentAlignment.MiddleCenter };
                }
            }

            this.SortTracklist((int)TrackColumns.Popularity, SortOrder.Descending);

            if (this.dataGridViewAlbums.Rows.Count > 0)
            {
                this.dataGridViewAlbums.Rows[0].Selected = true;
            }
        }

        /// <summary>
        /// dataGridViewAlbums SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewAlbums_SelectionChanged(object sender, EventArgs e)
        {
            int numVisibleRows = 0;
            foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
            {
                if (row.Visible)
                {
                    numVisibleRows++;
                }
            }

            if (numVisibleRows <= 2 || this.dataGridViewArtists.Rows.Count < 2)
            {
                // Return if the data grids haven't been fully populated yet or 
                // if there's only one album, switching between "All albums" and the album will give the same results
                return;
            }

            List<string> selectedArtistHrefs = new List<string>();
            bool allArtistsSelected = this.dataGridViewArtists.Rows[0].Selected;
            foreach (DataGridViewRow row in this.dataGridViewArtists.Rows)
            {
                if (row.Index != 0 && (allArtistsSelected || row.Selected))
                {
                    if (row.Tag is SearchTrack)
                    {
                        selectedArtistHrefs.Add((row.Tag as SearchTrack).Artist.Href);
                    }
                    else if (row.Tag is ArtistTrack)
                    {
                        selectedArtistHrefs.Add((row.Tag as ArtistTrack).Artist.Href);
                    }
                    else if (row.Tag is Track)
                    {
                        selectedArtistHrefs.Add((row.Tag as Track).Artist.Href);
                    }
                }
            }

            List<string> selectedAlbumHrefs = new List<string>();
            if (dataGridViewAlbums.Rows[0].Selected)
            {
                foreach (DataGridViewRow row in this.dataGridViewAlbums.Rows)
                {
                    if (row.Index != 0)
                    {
                        row.Selected = false;

                        if (row.Visible)
                        {
                            if (row.Tag is List<SearchTrack>)
                            {
                                List<SearchTrack> tracks = row.Tag as List<SearchTrack>;
                                selectedAlbumHrefs.Add(tracks[0].Album.Href);
                            }
                            else if (row.Tag is List<Track>)
                            {
                                List<Track> tracks = row.Tag as List<Track>;
                                selectedAlbumHrefs.Add(tracks[0].Album.Href);
                            }
                            else if (row.Tag is Album)
                            {
                                Album album = row.Tag as Album;
                                selectedAlbumHrefs.Add(album.Href);
                            }
                        }
                    }
                }
            }
            else
            {
                foreach (DataGridViewRow row in this.dataGridViewAlbums.SelectedRows)
                {
                    if (row.Tag is List<SearchTrack>)
                    {
                        List<SearchTrack> tracks = row.Tag as List<SearchTrack>;
                        selectedAlbumHrefs.Add(tracks[0].Album.Href);
                    }
                    else if (row.Tag is List<Track>)
                    {
                        List<Track> tracks = row.Tag as List<Track>;
                        selectedAlbumHrefs.Add(tracks[0].Album.Href);
                    }
                    else if (row.Tag is Album)
                    {
                        Album album = row.Tag as Album;
                        selectedAlbumHrefs.Add(album.Href);
                    }
                }
            }

            int visibleCount = 0;
            this.dataGridViewTracks.AlternatingRowsDefaultCellStyle = null;
            foreach (DataGridViewRow row in this.dataGridViewTracks.Rows)
            {
                string albumHref = string.Empty;
                string artistHref = string.Empty;
                if (row.Tag is SearchTrack)
                {
                    SearchTrack track = row.Tag as SearchTrack;
                    albumHref = track.Album.Href;
                    artistHref = track.Artist.Href;
                }
                else if (row.Tag is Track)
                {
                    Track track = row.Tag as Track;
                    albumHref = track.Album.Href;
                    artistHref = track.Artist.Href;
                }
                else if (row.Tag is Tuple<ArtistTrack, Album>)
                {
                    Tuple<ArtistTrack, Album> track = row.Tag as Tuple<ArtistTrack, Album>;
                    albumHref = track.Item2.Href;
                    artistHref = track.Item1.Artist.Href;
                }

                if (row.Visible = selectedAlbumHrefs.Contains(albumHref) && selectedArtistHrefs.Contains(artistHref))
                {
                    visibleCount++;
                }

                row.DefaultCellStyle = visibleCount % 2 == 1 ? this.dataGridViewTracks.DefaultCellStyle : this.alternateStyle;
                row.Cells[(int)TrackColumns.Popularity].Style = new DataGridViewCellStyle(row.DefaultCellStyle) { Alignment = DataGridViewContentAlignment.MiddleCenter };
            }

            if (dataGridViewAlbums.Rows[0].Selected)
            {
                this.SortTracklist((int)TrackColumns.Popularity, SortOrder.Descending);
            }
            else
            {
                this.SortTracklist((int)TrackColumns.TrackNumber, SortOrder.Ascending);
            }
        }

        /// <summary>
        /// newCollectionToolStripMenuItem Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void newCollectionToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AddNewCollection anc = new AddNewCollection();
            if (DialogResult.OK == anc.ShowDialog(this))
            {
                if (this.collections.ContainsKey(anc.CollectionName))
                {
                    MessageBox.Show(Properties.Resources.CollectionAlreadyExists, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                else
                {
                    this.AddTracksToCollection(anc.CollectionName);
                }
            }
        }

        /// <summary>
        /// Adds the selected tracks to the given collection
        /// </summary>
        /// <param name="collectionName">Name of collection to add to</param>
        private void AddTracksToCollection(string collectionName)
        {
            HashSet<string> hrefs = new HashSet<string>();
            foreach (DataGridViewRow row in this.dataGridViewTracks.SelectedRows)
            {
                // DataGridView is stupid and selects hidden rows if you shift-click to select multiple rows
                if (row.Visible)
                {
                    hrefs.Add(this.GetTrackHrefFromTag(row.Tag).Replace("spotify:track:", string.Empty));
                }
            }

            if (!this.collections.Any())
            {
                this.dataGridViewCollections.Rows.Insert(0, "(All)");
                this.addToCollectionToolStripMenuItem.DropDownItems.Add(new ToolStripSeparator());
            }

            if (this.collections.ContainsKey(collectionName))
            {
                foreach (string href in hrefs)
                {
                    this.collections[collectionName].Add(href);
                }
            }
            else
            {
                ToolStripMenuItem item = new ToolStripMenuItem(collectionName);
                item.Click += (iSender, iArgs) =>
                {
                    this.AddTracksToCollection(collectionName);
                };

                this.addToCollectionToolStripMenuItem.DropDownItems.Add(item);

                this.collections[collectionName] = hrefs;
                this.dataGridViewCollections.Rows.Add(collectionName);
            }

            this.SaveCollections();
        }

        /// <summary>
        /// Sets the value of the progress bar
        /// </summary>
        /// <param name="valueToSet">Value to set</param>
        /// <param name="maxValueToSet">Maximum value to set</param>
        private void SetProgressBar(int valueToSet, int maxValueToSet = -1)
        {
            if (maxValueToSet >= 0)
            {
                this.progressBar.Maximum = maxValueToSet;
                this.progressBar.Visible = true;
            }

            this.progressBar.Value = valueToSet;
        }

        /// <summary>
        /// Hides the progress bar
        /// </summary>
        private void HideProgressBar()
        {
            this.progressBar.Visible = false;
        }

        /// <summary>
        /// toolStripMenuItemFindDuplicates Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripMenuItemFindDuplicates_Click(object sender, EventArgs e)
        {
            var tuples = new List<Tuple<double, DataGridViewRow, DataGridViewRow>>();
            BackgroundWorker bw = new BackgroundWorker() { WorkerReportsProgress = true };
            bw.DoWork += (bwSender, bwArgs) =>
            {
                for (int i = 0; i < this.dataGridViewTracks.Rows.Count - 1; i++)
                {
                    bw.ReportProgress(0, i);
                    for (int j = i + 1; j < this.dataGridViewTracks.Rows.Count; j++)
                    {
                        object track1 = this.dataGridViewTracks.Rows[i].Tag;
                        object track2 = this.dataGridViewTracks.Rows[j].Tag;
                        double similarity = TrackComparer.Compare(track1, track2);
                        tuples.Add(new Tuple<double, DataGridViewRow, DataGridViewRow>(similarity, this.dataGridViewTracks.Rows[i], this.dataGridViewTracks.Rows[j]));
                    }
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                int count = (int)bwArgs.UserState + 1;
                this.SetProgressBar(count, this.dataGridViewTracks.Rows.Count);
                this.SetStatus(string.Format(Properties.Resources.FindingDuplicates, count, this.dataGridViewTracks.Rows.Count));
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                this.ClearStatus();
                this.HideProgressBar();
                this.SetBusyState(false);

                tuples = tuples.Where(t => t.Item1 > 80).OrderBy(t => t.Item1).Reverse().ToList();

                if (tuples.Any())
                {
                    this.dataGridViewTracks.Rows.Clear();
                    foreach (var tuple in tuples)
                    {
                        if (!this.dataGridViewTracks.Rows.Contains(tuple.Item2))
                        {
                            this.dataGridViewTracks.Rows.Add(tuple.Item2);
                        }

                        if (!this.dataGridViewTracks.Rows.Contains(tuple.Item3))
                        {
                            this.dataGridViewTracks.Rows.Add(tuple.Item3);
                        }
                    }
                }
                else
                {
                    MessageBox.Show(Properties.Resources.NoDuplicatesFound, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            };

            this.SetBusyState(true);
            bw.RunWorkerAsync();
        }

        /// <summary>
        /// toolStripMenuItemPlay Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripMenuItemPlay_Click(object sender, EventArgs e)
        {
            if (this.dataGridViewTracks.SelectedRows.Count == 0)
            {
                return;
            }

            if (this.dataGridViewTracks.SelectedRows.Count == 1)
            {
                string track = this.GetTrackHrefFromTag(this.dataGridViewTracks.SelectedRows[0].Tag);
                this.SendToServer(track + "|Play");
            }
            else
            {
                List<string> tracks = new List<string>();
                for (int i = this.dataGridViewTracks.SelectedRows.Count; i > 0; i--)
                {
                    tracks.Add(this.GetTrackHrefFromTag(this.dataGridViewTracks.SelectedRows[i - 1].Tag).Replace("spotify:track:", string.Empty));
                }

                string trackset = "http://open.spotify.com/trackset/Spotify/" + string.Join(",", tracks);
                this.SendToServer(trackset + "|Play");
            }
        }

        /// <summary>
        /// Represents a packet
        /// </summary>
        public class SocketPacket
        {
            /// <summary>
            /// Initializes a new instance of the SocketPacket class
            /// </summary>
            public SocketPacket()
            {
                this.Buffer = new byte[1];
            }

            /// <summary>
            /// Gets or sets the corresponding socket
            /// </summary>
            public Socket Socket { get; set; }

            /// <summary>
            /// Gets or sets the buffer to store packet data
            /// </summary>
            public byte[] Buffer { get; set; }
        }

        /// <summary>
        /// Represents host information
        /// </summary>
        public class HostData
        {
            /// <summary>
            /// Gets or sets the hosts' IP address
            /// </summary>
            public IPAddress IPAddress { get; set; }

            /// <summary>
            /// Gets or sets the host's associated socket
            /// </summary>
            public Socket Socket { get; set; }

            /// <summary>
            /// Gets or sets the hosts' connection status
            /// </summary>
            public ClientConnectStatus ConnectionStatus { get; set; }

            /// <summary>
            /// Gets or sets the associated row in the host data grid
            /// </summary>
            public DataGridViewRow Row { get; set; }

            /// <summary>
            /// Gets or sets the timer used to update the Spotify status
            /// </summary>
            public Timer Timer { get; set; }
        }
    }
}