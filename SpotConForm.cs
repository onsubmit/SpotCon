//-----------------------------------------------------------------------
// <copyright file="SpotConForm.cs" company="Andy Young">
//     Copyright (c) Andy Young. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace SpotCon
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.DirectoryServices;
    using System.Drawing;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Windows.Forms;
    using SpotifyWebApi.SpotifyResponses.Lookup;
    using SpotifyWebApi.SpotifyResponses.Search;
    using SpotifyWebApi.SpotifyServices;
    using SpotifyWebHelperSharp;

    /// <summary>
    /// Main form
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.NamingRules", "SA1300:ElementMustBeginWithUpperCaseLetter", Justification = "WinForms autogenerated method names.")]
    [SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1650:ElementDocumentationMustBeSpelledCorrectly", Justification = "'Spotify' is spelled correctly, dummy.")]
    public partial class SpotConForm : Form
    {
        /// <summary>
        /// WM_APPCOMMAND
        /// <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms646275(v=vs.85).aspx</remarks>
        /// </summary>
        private const int WM_APPCOMMAND = 0x0319;

        /// <summary>
        /// VK_CONTROL
        /// </summary>
        private const int VK_CONTROL = 0x11;

        /// <summary>
        /// VK_DOWN
        /// </summary>
        private const int WM_KEYDOWN = 0x0100;

        /// <summary>
        /// WM_KEYDOWN
        /// </summary>
        private const int WM_KEYUP = 0x0101;

        /// <summary>
        /// VK_UP
        /// </summary>
        private const int VK_UP = 0x26;

        /// <summary>
        /// VK_DOWN
        /// </summary>
        private const int VK_DOWN = 0x28;

        /// <summary>
        /// APPCOMMAND_VOLUME_MUTE (8)
        /// </summary>
        private const int APPCOMMAND_VOLUME_MUTE = 524288;

        /// <summary>
        /// APPCOMMAND_VOLUME_DOWN (9)
        /// </summary>
        private const int APPCOMMAND_VOLUME_DOWN = 589824;

        /// <summary>
        /// APPCOMMAND_VOLUME_UP (10)
        /// </summary>
        private const int APPCOMMAND_VOLUME_UP = 655360;

        /// <summary>
        /// APPCOMMAND_MEDIA_NEXTTRACK (11)
        /// </summary>
        private const int APPCOMMAND_MEDIA_NEXTTRACK = 720896;

        /// <summary>
        /// APPCOMMAND_MEDIA_PREVIOUSTRACK (12)
        /// </summary>
        private const int APPCOMMAND_MEDIA_PREVIOUSTRACK = 786432;

        /// <summary>
        /// APPCOMMAND_MEDIA_STOP (13)
        /// </summary>
        private const int APPCOMMAND_MEDIA_STOP = 851968;

        /// <summary>
        /// APPCOMMAND_MEDIA_PLAY_PAUSE (14)
        /// </summary>
        private const int APPCOMMAND_MEDIA_PLAY_PAUSE = 917504;

        /// <summary>
        /// TCP port to use
        /// </summary>
        private const int Port = 1729;

        /// <summary>
        /// Lock for sending packets
        /// </summary>
        private readonly object sendLock = new object();

        /// <summary>
        /// Lock for receiving packets
        /// </summary>
        private readonly object receiveLock = new object();

        /// <summary>
        /// The name of the current host
        /// </summary>
        private string currentHost;

        /// <summary>
        /// The name of the currently selected host
        /// </summary>
        private string selectedHost;

        /// <summary>
        /// Buffer for server input
        /// </summary>
        private string inputFromServer;

        /// <summary>
        /// Buffer for client input
        /// </summary>
        private string inputFromClient;

        /// <summary>
        /// The current status of Spotify
        /// </summary>
        private Responses.Status currentStatus;

        /// <summary>
        /// The number of milliseconds to wait between each attempt to update status from Spotify
        /// </summary>
        private int defaultWaitTime = 1000;

        /// <summary>
        /// Server listener socket
        /// </summary>
        private Socket listener;

        /// <summary>
        /// Asynchronous callback for server
        /// </summary>
        private AsyncCallback callbackServer;

        /// <summary>
        /// Asynchronous callback for client
        /// </summary>
        private AsyncCallback callbackClient;

        /// <summary>
        /// Temporary placeholder for newly created server worker sockets
        /// </summary>
        private Socket newWorker;

        /// <summary>
        /// Host images
        /// </summary>
        private ImageList hostImages = new ImageList();

        /// <summary>
        /// Popularity images
        /// </summary>
        private ImageList popImages = new ImageList();

        /// <summary>
        /// Popularity images (selected)
        /// </summary>
        private ImageList popSelectedImages = new ImageList();

        /// <summary>
        /// List of commands that execute in response to client or server requests
        /// </summary>
        private Dictionary<string, Action<string, string, string>> commands;

        /// <summary>
        /// Used to retrieve status from Spotify
        /// </summary>
        private SpotifyWebHelper webHelper;

        /// <summary>
        /// Host information
        /// </summary>
        private Dictionary<string, HostData> hostData = new Dictionary<string, HostData>();

        /// <summary>
        /// Server worker sockets
        /// </summary>
        private Dictionary<string, Socket> workers = new Dictionary<string, Socket>();

        /// <summary>
        /// Tracks the list of selected track row indices
        /// </summary>
        private List<int> selectedTrackRowIndices = new List<int>();

        /// <summary>
        /// Handle to Spotify window
        /// </summary>
        private IntPtr spotifyHwnd = IntPtr.Zero;

        /// <summary>
        /// Spotify Search service
        /// </summary>
        private SearchService search;

        /// <summary>
        /// Spotify Lookup service
        /// </summary>
        private LookupService lookup;

        /// <summary>
        /// Tooltip for track
        /// </summary>
        private ToolTip tooltipTrack = new ToolTip();

        /// <summary>
        /// Tooltip for artist
        /// </summary>
        private ToolTip tooltipArtist = new ToolTip();

        /// <summary>
        /// History of actions that can be traversed
        /// </summary>
        private List<Action> history = new List<Action>();

        /// <summary>
        /// Current index in the history
        /// </summary>
        private int historyIndex = 0;

        /// <summary>
        /// Initializes a new instance of the SpotConForm class
        /// </summary>
        public SpotConForm()
        {
            this.InitializeComponent();

            this.commands = new Dictionary<string, Action<string, string, string>>()
            {
                {
                    "|Connected",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        this.workers[orig] = this.newWorker;

                        if (orig != currentHost)
                        {
                            this.SetStatus(string.Format(Properties.Resources.ClientConnected, orig));
                        }
                    })
                },
                {
                    "|Previous",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, WM_APPCOMMAND, 0, APPCOMMAND_MEDIA_PREVIOUSTRACK);
                    })
                },
                {
                    "|Play",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        this.webHelper.Play(s);
                    })
                },
                {
                    "|Next",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, WM_APPCOMMAND, 0, APPCOMMAND_MEDIA_NEXTTRACK);
                    })
                },
                {
                    "|Pause",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        SendMessage(this.spotifyHwnd, WM_APPCOMMAND, 0, APPCOMMAND_MEDIA_PLAY_PAUSE);
                    })
                },
                {
                    "|SetVolume",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        string[] split = s.Split(':');
                        double desired = 0;
                        double.TryParse(split[0], out desired);

                        double current = 0;
                        double.TryParse(split[1], out current);

                        string action = desired < current ? "{DOWN}" : "{UP}";

                        bool success = SetForegroundWindow(this.spotifyHwnd);
                        for (int i = 0; i <= 100 * Math.Abs((desired - current) / 6.25); i++)
                        {
                            System.Threading.Thread.Sleep(10);
                            SendKeys.Send(string.Format("^({0})", action));
                            System.Threading.Thread.Sleep(10);
                        }

                        if(dest == this.currentHost)
                        {
                            success = SetForegroundWindow(this.Handle);
                        }
                    })
                },
                {
                    "|GetStatusFromServer",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        string response = string.Empty;
                        webHelper.GetStatus(out response);
                        this.SendToClient(response + "|ServerStatusReturned", orig);
                    })
                },
                {
                    "|ServerStatusReturned",
                    new Action<string, string, string>((dest, orig, s) =>
                    {
                        Responses.Status status = webHelper.Deserialize<Responses.Status>(s);
                        bool success = this.UpdateStatus(status);
                        string currentAlbumUri = this.currentStatus == null ? null : this.currentStatus.Track.AlbumResource.Uri;
                        this.currentStatus = status;

                        if (success && status.Track.AlbumResource.Uri != currentAlbumUri)
                        {
                            BackgroundWorker bw = new BackgroundWorker();
                            bw.DoWork += (bwSender, bwArgs) =>
                            {
                                Tuple<string, string> art = webHelper.GetArt(status.Track);
                                bwArgs.Result = art;
                            };

                            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
                            {
                                Tuple<string, string> art = bwArgs.Result as Tuple<string, string>;
                                pictureBox.LoadAsync(art.Item2);
                            };

                            bw.RunWorkerAsync();
                        }
                    })
                }
            };
        }

        /// <summary>
        /// Represents the connect status of the client
        /// </summary>
        public enum ClientConnectStatus
        {
            /// <summary>
            /// Client is disconnected
            /// </summary>
            Disconnected,

            /// <summary>
            /// Client is connected
            /// </summary>
            Connected,

            /// <summary>
            /// Client couldn't connect
            /// </summary>
            ConnectionFailure
        }

        /// <summary>
        /// Represents a column in the host data grid
        /// </summary>
        public enum HostColumns
        {
            /// <summary>
            /// Checkbox column
            /// </summary>
            Checkbox,

            /// <summary>
            /// Connection status column
            /// </summary>
            ConnectionStatus,

            /// <summary>
            /// Name column
            /// </summary>
            Name
        }

        /// <summary>
        /// Represents a column in the tracks data grid
        /// </summary>
        public enum TrackColumns
        {
            /// <summary>
            /// Padding column
            /// </summary>
            Padding,

            /// <summary>
            /// Track column
            /// </summary>
            Track,

            /// <summary>
            /// Artist column
            /// </summary>
            Artist,

            /// <summary>
            /// Time column
            /// </summary>
            Time,

            /// <summary>
            /// Popularity column
            /// </summary>
            Popularity,

            /// <summary>
            /// Album column
            /// </summary>
            Album
        }

        /// <summary>
        /// Represents the type of search that is occurring
        /// </summary>
        public enum SearchType
        {
            /// <summary>
            /// Artist search
            /// </summary>
            Artist,

            /// <summary>
            /// Album search
            /// </summary>
            Album,

            /// <summary>
            /// Track search
            /// </summary>
            Track
        }

        /// <summary>
        /// Sends the specified message to a window or windows.
        /// The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.
        /// </summary>
        /// <param name="hWnd">A handle to the window whose window procedure will receive the message.</param>
        /// <param name="msg">The message to be sent.</param>
        /// <param name="wParam">Additional message-specific information. (UINT_PTR)</param>
        /// <param name="lParam">Additional message-specific information. (LONG_PTR)</param>
        /// <returns>The return value specifies the result of the message processing; it depends on the message sent.</returns>
        [DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint msg, int wParam, int lParam);

        /// <summary>
        /// Brings the thread that created the specified window into the foreground and activates the window.
        /// </summary>
        /// <param name="hWnd">A handle to the window that should be activated and brought to the foreground.</param>
        /// <returns>If the window was brought to the foreground, the return value is nonzero. Zero otherwise.</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        /// <summary>
        /// Invoked when a new client connects
        /// </summary>
        /// <param name="result">Connection result</param>
        private void OnClientConnect(IAsyncResult result)
        {
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                try
                {
                    // Complete the BeginAccept() asynchronous call by calling EndAccept() which returns a reference to the new socket
                    Socket socket = this.listener.EndAccept(result);
                    this.newWorker = socket;

                    // Let the worker socket do further processing for the just connected client
                    WaitForDataServer(socket);

                    // Since the main socket is now free, it can go back and wait for other clients who are attempting to connect
                    listener.BeginAccept(new AsyncCallback(OnClientConnect), null);
                }
                catch (ObjectDisposedException)
                {
                    System.Diagnostics.Debugger.Log(0, "1", "\n OnClientConnection: Socket has been closed\n");
                }
                catch (Exception ex)
                {
                    bwArgs.Result = ex;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (bwArgs.Result is Exception && this.InvokeRequired)
                {
                    this.BeginInvoke((Delegate)(new Action(() => this.SetStatusError((bwArgs.Result as Exception).Message))));
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Invoked when data is received by the server
        /// </summary>
        /// <param name="result">Data result</param>
        private void OnDataReceivedByServer(IAsyncResult result)
        {
            SocketPacket packet = (SocketPacket)result.AsyncState;

            // Complete the BeginReceive() asynchronous call by the EndReceive() method which will return the number of characters written to the stream by the client
            if (packet.Socket.Connected)
            {
                lock (this.receiveLock)
                {
                    int byteCount = 0;
                    try
                    {
                        byteCount = packet.Socket.EndReceive(result);
                    }
                    catch (SocketException)
                    {
                        return;
                    }

                    char[] chars = new char[byteCount];
                    int charLen = Encoding.UTF8.GetChars(bytes: packet.Buffer, byteIndex: 0, byteCount: byteCount, chars: chars, charIndex: 0);
                    string data = new string(chars);
                    this.inputFromClient += data;

                    foreach (var command in this.commands)
                    {
                        if (this.inputFromClient.EndsWith(command.Key))
                        {
                            string input = this.inputFromClient.Replace(command.Key, string.Empty);
                            this.inputFromClient = string.Empty;

                            string[] split = input.Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                            string originatingClient = split[0];
                            input = split.Length > 1 ? split[1] : string.Empty;

                            if (this.InvokeRequired)
                            {
                                this.BeginInvoke((Delegate)command.Value, this.currentHost, originatingClient, input);
                            }

                            break;
                        }
                    }

                    // Continue the waiting for data on the socket
                    this.WaitForDataServer(packet.Socket);
                }
            }
        }

        /// <summary>
        /// Invoked when data is received by the client
        /// </summary>
        /// <param name="result">Data result</param>
        private void OnDataReceivedByClient(IAsyncResult result)
        {
            SocketPacket packet = (SocketPacket)result.AsyncState;

            // Complete the BeginReceive() asynchronous call by the EndReceive() method which will return the number of characters written to the stream by the client
            if (packet.Socket.Connected)
            {
                lock (this.receiveLock)
                {
                    int byteCount = 0;
                    try
                    {
                        byteCount = packet.Socket.EndReceive(result);
                    }
                    catch (SocketException)
                    {
                        return;
                    }

                    char[] chars = new char[byteCount];
                    int charLen = Encoding.UTF8.GetChars(bytes: packet.Buffer, byteIndex: 0, byteCount: byteCount, chars: chars, charIndex: 0);
                    string data = new string(chars);
                    this.inputFromServer += data;

                    foreach (var command in this.commands)
                    {
                        if (this.inputFromServer.EndsWith(command.Key))
                        {
                            string input = this.inputFromServer.Replace(command.Key, string.Empty);
                            this.inputFromServer = string.Empty;

                            string[] split = input.Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                            string originatingServer = split[0];
                            input = split.Length > 1 ? split[1] : string.Empty;

                            if (this.InvokeRequired)
                            {
                                this.BeginInvoke((Delegate)command.Value, this.currentHost, originatingServer, input);
                            }

                            break;
                        }
                    }

                    // Continue the waiting for data on the socket
                    this.WaitForDataClient(packet.Socket);
                }
            }
        }

        /// <summary>
        /// Invoked when the server begins waiting for data
        /// </summary>
        /// <param name="socket">Server socket</param>
        private void WaitForDataServer(Socket socket)
        {
            try
            {
                if (this.callbackServer == null)
                {
                    // Specify the callback function which is to be invoked when there is any write activity by the connected client
                    this.callbackServer = new AsyncCallback(this.OnDataReceivedByServer);
                }

                SocketPacket socketPacket = new SocketPacket() { Socket = socket };

                // Start receiving any data written by the connected client asynchronously
                socket.BeginReceive(buffer: socketPacket.Buffer, offset: 0, size: socketPacket.Buffer.Length, socketFlags: SocketFlags.None, callback: this.callbackServer, state: socketPacket);
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Invoked when the client begins waiting for data
        /// </summary>
        /// <param name="socket">Client socket</param>
        private void WaitForDataClient(Socket socket)
        {
            try
            {
                if (this.callbackClient == null)
                {
                    // Specify the callback function which is to be invoked when there is any write activity by the connected client
                    this.callbackClient = new AsyncCallback(this.OnDataReceivedByClient);
                }

                SocketPacket socketPacket = new SocketPacket() { Socket = socket };

                // Start receiving any data written by the connected client asynchronously
                socket.BeginReceive(buffer: socketPacket.Buffer, offset: 0, size: socketPacket.Buffer.Length, socketFlags: SocketFlags.None, callback: this.callbackClient, state: socketPacket);
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// SpotConForm Load event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_Load(object sender, EventArgs e)
        {
            this.history.Add(() =>
            {
                this.dataGridViewTracks.Rows.Clear();
                this.ClearStatus();
            });

            this.panelBack.Tag = false;
            this.panelForward.Tag = false;

            this.ActiveControl = this.panelPlayPause;
            this.textBoxSearch.Tag = this.textBoxSearch.ForeColor;

            this.ClearStatus();
            this.SetStatusBusy(Properties.Resources.SearchingNetwork);

            this.hostImages.Images.Add(Properties.Resources.Computer);
            this.hostImages.Images.Add(Properties.Resources.ComputerLink);
            this.hostImages.Images.Add(Properties.Resources.ComputerError);

            this.popImages.ImageSize = new Size(65, 8);
            this.popImages.Images.Add(Properties.Resources.pop00);
            this.popImages.Images.Add(Properties.Resources.pop01);
            this.popImages.Images.Add(Properties.Resources.pop02);
            this.popImages.Images.Add(Properties.Resources.pop03);
            this.popImages.Images.Add(Properties.Resources.pop04);
            this.popImages.Images.Add(Properties.Resources.pop05);
            this.popImages.Images.Add(Properties.Resources.pop06);
            this.popImages.Images.Add(Properties.Resources.pop07);
            this.popImages.Images.Add(Properties.Resources.pop08);
            this.popImages.Images.Add(Properties.Resources.pop09);
            this.popImages.Images.Add(Properties.Resources.pop10);
            this.popImages.Images.Add(Properties.Resources.pop11);
            this.popImages.Images.Add(Properties.Resources.pop12);
            this.popImages.Images.Add(Properties.Resources.pop13);
            this.popImages.Images.Add(Properties.Resources.pop14);
            this.popImages.Images.Add(Properties.Resources.pop15);
            this.popImages.Images.Add(Properties.Resources.pop16);
            this.popImages.Images.Add(Properties.Resources.pop17);
            this.popImages.Images.Add(Properties.Resources.pop18);
            this.popImages.Images.Add(Properties.Resources.pop19);
            this.popImages.Images.Add(Properties.Resources.pop20);
            this.popImages.Images.Add(Properties.Resources.pop21);
            this.popImages.Images.Add(Properties.Resources.pop22);

            this.popSelectedImages.ImageSize = new Size(65, 8);
            this.popSelectedImages.Images.Add(Properties.Resources.pops00);
            this.popSelectedImages.Images.Add(Properties.Resources.pops01);
            this.popSelectedImages.Images.Add(Properties.Resources.pops02);
            this.popSelectedImages.Images.Add(Properties.Resources.pops03);
            this.popSelectedImages.Images.Add(Properties.Resources.pops04);
            this.popSelectedImages.Images.Add(Properties.Resources.pops05);
            this.popSelectedImages.Images.Add(Properties.Resources.pops06);
            this.popSelectedImages.Images.Add(Properties.Resources.pops07);
            this.popSelectedImages.Images.Add(Properties.Resources.pops08);
            this.popSelectedImages.Images.Add(Properties.Resources.pops09);
            this.popSelectedImages.Images.Add(Properties.Resources.pops10);
            this.popSelectedImages.Images.Add(Properties.Resources.pops11);
            this.popSelectedImages.Images.Add(Properties.Resources.pops12);
            this.popSelectedImages.Images.Add(Properties.Resources.pops13);
            this.popSelectedImages.Images.Add(Properties.Resources.pops14);
            this.popSelectedImages.Images.Add(Properties.Resources.pops15);
            this.popSelectedImages.Images.Add(Properties.Resources.pops16);
            this.popSelectedImages.Images.Add(Properties.Resources.pops17);
            this.popSelectedImages.Images.Add(Properties.Resources.pops18);
            this.popSelectedImages.Images.Add(Properties.Resources.pops19);
            this.popSelectedImages.Images.Add(Properties.Resources.pops20);
            this.popSelectedImages.Images.Add(Properties.Resources.pops21);
            this.popSelectedImages.Images.Add(Properties.Resources.pops22);

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                try
                {
                    this.webHelper = new SpotifyWebHelper();
                    this.search = new SearchService();
                    this.lookup = new LookupService();

                    listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                    // Bind to local IP address
                    IPEndPoint ipLocal = new IPEndPoint(IPAddress.Any, Port);
                    listener.Bind(ipLocal);

                    // Start listening
                    listener.Listen(backlog: 4);

                    // Create the call back for any client connections...
                    listener.BeginAccept(new AsyncCallback(OnClientConnect), state: null);

                    this.currentHost = Dns.GetHostName().ToUpper();

                    DirectoryEntry entry = new DirectoryEntry("WinNT:");
                    List<string> names = (from DirectoryEntry domains in entry.Children
                                          from DirectoryEntry pc in domains.Children
                                          where pc.SchemaClassName.ToLower().Contains("computer")
                                          select pc.Name.ToUpper()).ToList();

                    if (!names.Any())
                    {
                        names.Add(this.currentHost);
                    }

                    bwArgs.Result = names;
                }
                catch (Exception ex)
                {
                    bwArgs.Result = ex;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (bwArgs.Result is Exception)
                {
                    Exception ex = bwArgs.Result as Exception;
                    this.SetStatusError(ex.Message);
                    return;
                }
                else
                {
                    List<string> names = bwArgs.Result as List<string>;
                    foreach (var name in names)
                    {
                        try
                        {
                            this.hostData[name] = new HostData() { IPAddress = Dns.GetHostAddresses(name).FirstOrDefault(i => i.AddressFamily == AddressFamily.InterNetwork) };
                            int index = dataGridViewComputers.Rows.Add(name.Equals(this.currentHost, StringComparison.OrdinalIgnoreCase), hostImages.Images[(int)ClientConnectStatus.Disconnected], name);
                            this.hostData[name].Row = dataGridViewComputers.Rows[index];
                        }
                        catch
                        {
                        }
                    }

                    bool exit = false;
                    Process[] processes = null;

                    while (!exit)
                    {
                        processes = Process.GetProcessesByName("spotify");
                        if (processes.Any())
                        {
                            this.spotifyHwnd = processes[0].MainWindowHandle;
                            break;
                        }

                        if (DialogResult.Cancel == MessageBox.Show(this, Properties.Resources.SpotifyNotFound, Properties.Resources.SpotifyNotFoundHeader, MessageBoxButtons.RetryCancel, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1))
                        {
                            exit = true;
                        }
                    }

                    if (exit)
                    {
                        Application.Exit();
                    }

                    GlobalMouseHandler globalClick = new GlobalMouseHandler()
                    {
                        BackAction = () => this.GoBack(),
                        ForwardAction = () => this.GoForward()
                    };

                    Application.AddMessageFilter(globalClick);

                    if (names.Contains(this.currentHost))
                    {
                        this.selectedHost = this.currentHost;
                        this.ConnectToServer((int)HostColumns.Checkbox, this.hostData[this.currentHost].Row.Index, this.currentHost);
                    }
                }
            };

            bw.RunWorkerAsync(bw);
        }

        /// <summary>
        /// Clears the current status
        /// </summary>
        private void ClearStatus()
        {
            this.SetStatus(string.Empty);
        }

        /// <summary>
        /// Sets the status to busy
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusBusy(string message)
        {
            this.SetStatus(message);
            this.SetBusyState(true);
        }

        /// <summary>
        /// Sets the status after an error
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusError(string message)
        {
            this.SetStatus(message, Color.Red);
            this.SetBusyState(false);
        }

        /// <summary>
        /// Sets the status after a successful event
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatusSuccess(string message)
        {
            this.SetStatus(message);
            this.SetBusyState(false);
        }

        /// <summary>
        /// Sets the status
        /// </summary>
        /// <param name="message">Message to set</param>
        private void SetStatus(string message)
        {
            this.SetStatus(message, Color.FromKnownColor(KnownColor.ControlText));
        }

        /// <summary>
        /// Sets the status
        /// </summary>
        /// <param name="message">Message to set</param>
        /// <param name="color">Message color to use</param>
        private void SetStatus(string message, Color color)
        {
            labelStatus.Text = message;
            labelStatus.ForeColor = color;
        }

        /// <summary>
        /// Sets busy state
        /// </summary>
        /// <param name="busy">True to use wait cursor</param>
        private void SetBusyState(bool busy)
        {
            Cursor.Current = busy ? Cursors.WaitCursor : Cursors.Default;
            this.Cursor = busy ? Cursors.WaitCursor : Cursors.Default;
            this.UseWaitCursor = busy;
            Application.UseWaitCursor = busy;
        }

        /// <summary>
        /// SpotConForm FormClosed event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_FormClosed(object sender, FormClosedEventArgs e)
        {
            if (this.listener != null)
            {
                this.listener.Close();
            }

            foreach (Socket worker in this.workers.Values)
            {
                if (worker != null)
                {
                    worker.Close();
                }
            }

            foreach (var item in this.hostData.Values)
            {
                if (item.Socket != null)
                {
                    item.Socket.Close();
                }
            }
        }

        /// <summary>
        /// toolStripButtonPrevious Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripButtonPrevious_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Previous");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// toolStripButtonPlayPause Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripButtonPlayPause_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Pause");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// toolStripButtonNext Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripButtonNext_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Next");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        private void SendToServer(string command)
        {
            this.SendToServer(command, this.selectedHost, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="server">Destination server</param>
        private void SendToServer(string command, string server)
        {
            this.SendToServer(command, server, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the server
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="server">Destination server</param>
        /// <param name="client">Client name</param>
        private void SendToServer(string command, string server, string client)
        {
            try
            {
                if (this.hostData.ContainsKey(server) && this.hostData[server].Socket != null && this.hostData[server].Socket.Connected)
                {
                    lock (this.sendLock)
                    {
                        byte[] bytes = Encoding.ASCII.GetBytes(client + "|" + command);
                        this.hostData[server].Socket.Send(bytes);
                    }
                }
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        private void SendToClient(string command)
        {
            this.SendToClient(command, this.selectedHost, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="client">Destination client</param>
        private void SendToClient(string command, string client)
        {
            this.SendToClient(command, client, this.currentHost);
        }

        /// <summary>
        /// Sends the given command to the client
        /// </summary>
        /// <param name="command">Command to send</param>
        /// <param name="client">Destination client</param>
        /// <param name="server">Server name</param>
        private void SendToClient(string command, string client, string server)
        {
            try
            {
                if (this.workers.ContainsKey(client) && this.workers[client].Connected)
                {
                    lock (this.sendLock)
                    {
                        byte[] bytes = Encoding.ASCII.GetBytes(server + "|" + command);
                        this.workers[client].Send(bytes);
                    }
                }
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// dataGridViewComputers CellValueChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_CellValueChanged(object sender, DataGridViewCellEventArgs e)
        {
            if (e.ColumnIndex != (int)HostColumns.Checkbox || e.RowIndex < 0)
            {
                return;
            }

            bool isChecked = (bool)dataGridViewComputers[e.ColumnIndex, e.RowIndex].Value;
            string host = dataGridViewComputers[(int)HostColumns.Name, e.RowIndex].Value.ToString();

            if (!isChecked)
            {
                if (this.hostData.ContainsKey(host) && this.hostData[host].Socket != null && this.hostData[host].Socket.Connected)
                {
                    this.hostData[host].Timer.Stop();
                    this.hostData[host].Socket.Close();
                    this.hostData[host].ConnectionStatus = ClientConnectStatus.Disconnected;
                    dataGridViewComputers[(int)HostColumns.ConnectionStatus, e.RowIndex].Value = this.hostImages.Images[(int)ClientConnectStatus.Disconnected];
                    this.SetStatus(string.Format(Properties.Resources.DisconnectedFrom, host));
                }
            }
            else
            {
                this.ConnectToServer(e.ColumnIndex, e.RowIndex, host);
            }
        }

        /// <summary>
        /// Connects to the server
        /// </summary>
        /// <param name="colIndex">Column index of host data grid</param>
        /// <param name="rowIndex">Row index of host data grid</param>
        /// <param name="server">Server to which to connect</param>
        private void ConnectToServer(int colIndex, int rowIndex, string server)
        {
            dataGridViewComputers.Enabled = false;
            this.SetStatusBusy(Properties.Resources.AttemptingConnections);
            BackgroundWorker bw = new BackgroundWorker() { WorkerReportsProgress = true };
            bw.DoWork += (bwSender, bwArgs) =>
            {
                try
                {
                    Socket socket = this.hostData.ContainsKey(server) && this.hostData[server].Socket != null && this.hostData[server].Socket.Connected ? this.hostData[server].Socket : new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                    IPEndPoint remoteEndPoint = new IPEndPoint(this.hostData[server].IPAddress, Port);
                    IAsyncResult result = socket.BeginConnect(remoteEP: remoteEndPoint, callback: null, state: null);

                    bw.ReportProgress(0, string.Format(Properties.Resources.ConnectingToClient, server));
                    bool success = result.AsyncWaitHandle.WaitOne(millisecondsTimeout: 3000, exitContext: true);
                    if (success)
                    {
                        this.hostData[server].Socket = socket;
                        this.hostData[server].ConnectionStatus = socket.Connected ? ClientConnectStatus.Connected : ClientConnectStatus.ConnectionFailure;

                        if (socket.Connected)
                        {
                            this.SendToServer("|Connected");
                        }
                    }
                    else
                    {
                        socket.Close();
                        this.hostData[server].ConnectionStatus = ClientConnectStatus.ConnectionFailure;
                    }

                    bwArgs.Result = success;
                }
                catch (Exception ex)
                {
                    bwArgs.Result = ex;
                }
            };

            bw.ProgressChanged += (bwSender, bwArgs) =>
            {
                this.SetStatusBusy(bwArgs.UserState as string);
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                dataGridViewComputers.Enabled = true;

                if (bwArgs.Result is Exception)
                {
                    Exception ex = bwArgs.Result as Exception;
                    this.SetStatusError(ex.Message);
                }
                else if (bwArgs.Result is bool)
                {
                    bool success = (bool)bwArgs.Result;
                    ClientConnectStatus status = this.hostData[server].ConnectionStatus;
                    dataGridViewComputers[(int)HostColumns.ConnectionStatus, rowIndex].Value = hostImages.Images[(int)status];
                    switch (status)
                    {
                        case ClientConnectStatus.Connected:
                            this.SetStatusSuccess(string.Format(Properties.Resources.ConnectingToClientSuccess, server));
                            dataGridViewComputers.Rows[rowIndex].Selected = true;

                            Timer timer = null;
                            if (this.hostData[server].Timer == null)
                            {
                                timer = new Timer() { Interval = this.defaultWaitTime, Enabled = true };
                                timer.Tick += (sender, e) =>
                                {
                                    BackgroundWorker bw2 = new BackgroundWorker();
                                    bw2.DoWork += (bw2Sender, bw2Args) =>
                                    {
                                        this.SendToServer("|GetStatusFromServer", server);
                                    };

                                    bw2.RunWorkerAsync();
                                };

                                this.hostData[server].Timer = timer;
                            }
                            else
                            {
                                timer = this.hostData[server].Timer;
                            }

                            foreach (var ip in this.hostData.Values.Where(i => i.Timer != null && i.Timer.Enabled))
                            {
                                ip.Timer.Stop();
                            }

                            timer.Start();
                            break;

                        case ClientConnectStatus.ConnectionFailure:
                            this.SetStatusError(string.Format(success ? Properties.Resources.ConnectingToClientUnknown : Properties.Resources.ConnectingToClientError, server));
                            dataGridViewComputers[colIndex, rowIndex].Value = false;
                            break;

                        case ClientConnectStatus.Disconnected:
                            this.ClearStatus();
                            break;
                    }

                    if (success)
                    {
                        this.WaitForDataClient(this.hostData[server].Socket);
                    }
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// dataGridViewComputers SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_SelectionChanged(object sender, EventArgs e)
        {
            if (dataGridViewComputers.SelectedRows.Count == 0)
            {
                return;
            }

            this.selectedHost = dataGridViewComputers.SelectedRows[0].Cells[(int)HostColumns.Name].Value.ToString();

            int selectedRowIndex = dataGridViewComputers.SelectedRows[0].Index;
            for (int i = 0; i < dataGridViewComputers.Rows.Count; i++)
            {
                DataGridViewCellStyle style = dataGridViewComputers.Rows[i].InheritedStyle;
                style.Font = new Font(style.Font, i == selectedRowIndex ? FontStyle.Bold : FontStyle.Regular);
                dataGridViewComputers.Rows[i].DefaultCellStyle = style;
            }

            foreach (var ip in this.hostData.Values.Where(i => i.Timer != null && i.Timer.Enabled))
            {
                ip.Timer.Stop();
            }

            if (this.hostData[this.selectedHost].Timer != null)
            {
                this.hostData[this.selectedHost].Timer.Start();
            }
        }

        /// <summary>
        /// dataGridViewComputers CurrentCellDirtyStateChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewComputers_CurrentCellDirtyStateChanged(object sender, EventArgs e)
        {
            if (dataGridViewComputers.IsCurrentCellDirty)
            {
                dataGridViewComputers.CommitEdit(DataGridViewDataErrorContexts.Commit);
            }
        }

        /// <summary>
        /// Updates the status
        /// </summary>
        /// <param name="status">Status to update</param>
        /// <returns>True if success</returns>
        private bool UpdateStatus(Responses.Status status)
        {
            if (status == null || status.OpenGraphState == null || status.OpenGraphState.PrivateSession)
            {
                this.SetStatusError(Properties.Resources.PrivateSessionError);
                return false;
            }

            if (status.Error != null)
            {
                this.SetStatusError(string.Format(Properties.Resources.StatusError, status.Error.Type));
                return false;
            }

            if (status.Track == null)
            {
                this.SetStatusError(string.Format(Properties.Resources.StatusError, string.Empty));
                return false;
            }

            if (this.linkLabelArtist.Text != status.Track.ArtistResource.Name)
            {
                this.linkLabelArtist.Text = status.Track.ArtistResource.Name;
                this.linkLabelArtist.Tag = status.Track.ArtistResource.Uri;
                this.linkLabelArtist.Enabled = true;
            }

            if (this.linkLabelTrack.Text != status.Track.TrackResource.Name)
            {
                this.linkLabelTrack.Text = status.Track.TrackResource.Name;
                this.linkLabelTrack.Tag = status.Track.TrackResource.Uri;
                this.linkLabelTrack.Enabled = true;
            }

            if (!panelPlayPause.Capture)
            {
                if (status.Playing)
                {
                    this.panelPlayPause.BackgroundImage = Properties.Resources.Pause;
                }
                else
                {
                    this.panelPlayPause.BackgroundImage = Properties.Resources.Play;
                }

                if (status.IsPlayEnabled)
                {
                    this.panelPlayPause.Enabled = true;
                }
                else
                {
                    this.panelPlayPause.Enabled = false;
                    this.panelPlayPause.BackgroundImage = Properties.Resources.PlayDisabled;
                }
            }

            if (!this.panelPrevious.Capture)
            {
                if (status.IsPrevEnabled)
                {
                    this.panelPrevious.Enabled = true;
                }
                else
                {
                    this.panelPrevious.Enabled = false;
                    this.panelPrevious.BackgroundImage = Properties.Resources.PreviousDisabled;
                }
            }

            if (!this.panelNext.Capture)
            {
                this.panelNext.Enabled = true;
            }

            if (!this.panelVolumeKnob.Capture)
            {
                this.panelVolumeKnob.Left = (int)((this.panelVolume.Width - this.panelVolumeKnob.Width) * status.Volume / 1.0);
            }

            string position = TimeSpan.FromSeconds(status.PlayingPosition).ToString(@"m\:ss");
            string end = TimeSpan.FromSeconds((double)status.Track.Length).ToString(@"m\:ss");
            this.labelTime.Text = string.Format("{0}/{1}", position, end);

            this.panelShuffle.BackgroundImage = status.Shuffle ? Properties.Resources.ShuffleGreen : Properties.Resources.Shuffle;
            this.panelRepeat.BackgroundImage = status.Repeat ? Properties.Resources.RepeatGreen : Properties.Resources.Repeat;

            return true;
        }

        /// <summary>
        /// Adds an action to the history queue
        /// </summary>
        /// <param name="action">Action to add</param>
        private void AddHistoryAction(Action action)
        {
            this.history.RemoveRange(this.historyIndex + 1, this.history.Count - this.historyIndex - 1);
            this.history.Add(action);
            this.historyIndex++;

            if (this.history.Count > 1)
            {
                this.panelBack.Tag = true;
                this.panelBack.BackgroundImage = Properties.Resources.Back;
            }

            if (this.historyIndex == this.history.Count - 1)
            {
                this.panelForward.Tag = false;
                this.panelForward.BackgroundImage = Properties.Resources.ForwardDisabled;
            }
        }

        /// <summary>
        /// Lookups the given album
        /// </summary>
        /// <param name="query">Album href</param>
        /// <param name="selectedTrackHref">Href of track to select</param>
        /// <param name="friendlyName">The query to display in the status bar</param>
        /// <param name="fromHistory">Indicates whether the method is being invoked from the history</param>
        private void LookupAlbum(string query, string selectedTrackHref, string friendlyName, bool fromHistory = false)
        {
            if (string.IsNullOrEmpty(query))
            {
                return;
            }

            if (!fromHistory)
            {
                string queryCopy = string.Copy(query);
                string selectedTrackHrefCopy = string.Copy(selectedTrackHref);
                this.AddHistoryAction(() => this.LookupAlbum(queryCopy, selectedTrackHrefCopy, friendlyName, fromHistory: true));
            }

            this.SetStatus(string.Format(Properties.Resources.Searching, friendlyName));
            this.dataGridViewTracks.Rows.Clear();
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                query = query.Split(':')[2];
                Album album = lookup.LookupAlbum(query, LookupService.AlbumExtras.TrackDetail);
                bwArgs.Result = album;
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                Album album = bwArgs.Result as Album;
                this.SetStatus(string.Format(Properties.Resources.DisplayResults, album.Tracks.Count, album.Tracks.Count == 1 ? string.Empty : "s", friendlyName));
                album.Tracks.ForEach(t =>
                {
                    DataGridViewRow row = new DataGridViewRow();
                    row.CreateCells(this.dataGridViewTracks, null, t.Name, t.Artist.Name, TimeSpan.FromSeconds((double)t.Length.Value).ToString(@"m\:ss"), this.GetPopularityImage(t.Popularity), album.Name);
                    row.Cells[(int)TrackColumns.Popularity].Tag = t.Popularity;
                    row.Cells[(int)TrackColumns.Time].Tag = t.Length.Value;
                    row.Tag = t;

                    this.dataGridViewTracks.Rows.Add(row);
                    row.Selected = t.Href == selectedTrackHref;
                });
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Searches the Spootify database
        /// </summary>
        /// <param name="query">Query to search</param>
        /// <param name="searchType">Type of search. Used in filtering the results</param>
        /// <param name="fromHistory">Indicates whether the method is being invoked from the history</param>
        private void Search(string query, SearchType? searchType = null, bool fromHistory = false)
        {
            if (string.IsNullOrEmpty(query))
            {
                return;
            }

            Action action = null;
            if (query.StartsWith("spotify:"))
            {
                action = new Action(() => this.SendToServer(query + "|Play"));
            }
            else if (query.StartsWith("http://open.spotify.com"))
            {
                action = new Action(() => this.SendToServer(query + "|Play"));
            }
            else
            {
                if (!fromHistory)
                {
                    this.AddHistoryAction(() => this.Search(query, searchType, fromHistory: true));
                }

                dataGridViewTracks.Rows.Clear();
                this.SetStatusBusy(string.Format(Properties.Resources.Searching, query));
            }

            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += (bwSender, bwArgs) =>
            {
                if (action != null)
                {
                    action.Invoke();
                }
                else
                {
                    List<SearchTrack> tracks = search.SearchTracks(query).TrackList;
                    if (searchType.HasValue)
                    {
                        switch (searchType.Value)
                        {
                            case SearchType.Album:
                                tracks = tracks.Where(t => t.Album.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                            case SearchType.Artist:
                                tracks = tracks.Where(t => t.Artist.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                            case SearchType.Track:
                                tracks = tracks.Where(t => t.Name.Equals(query, StringComparison.OrdinalIgnoreCase)).ToList();
                                break;
                        }
                    }

                    bwArgs.Result = tracks;
                }
            };

            bw.RunWorkerCompleted += (bwSender, bwArgs) =>
            {
                if (bwArgs.Result is List<SearchTrack>)
                {
                    List<SearchTrack> tracks = bwArgs.Result as List<SearchTrack>;
                    tracks.ForEach(t =>
                    {
                        DataGridViewRow row = new DataGridViewRow();
                        row.CreateCells(this.dataGridViewTracks, null, t.Name, t.Artist.Name, TimeSpan.FromSeconds((double)t.Length.Value).ToString(@"m\:ss"), this.GetPopularityImage(t.Popularity), t.Album.Name);
                        row.Cells[(int)TrackColumns.Popularity].Tag = t.Popularity;
                        row.Cells[(int)TrackColumns.Time].Tag = t.Length.Value;
                        row.Tag = t;

                        this.dataGridViewTracks.Rows.Add(row);
                    });

                    this.SetBusyState(false);
                    this.SetStatus(string.Format(Properties.Resources.DisplayResults, tracks.Count, tracks.Count == 1 ? string.Empty : "s", query));
                }
            };

            bw.RunWorkerAsync();
        }

        /// <summary>
        /// Gets the popularity image
        /// </summary>
        /// <param name="popularity">Track popularity value</param>
        /// <param name="selected">True if the row is selected</param>
        /// <returns>Desired popularity image</returns>
        private Image GetPopularityImage(double? popularity, bool selected = false)
        {
            ImageList imageList = selected ? this.popSelectedImages : this.popImages;
            int numImages = imageList.Images.Count - 1;
            int index = popularity.HasValue ? (int)((double)numImages * popularity) : 0;
            return imageList.Images[index];
        }

        /// <summary>
        /// dataGridViewTracks CellDoubleClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex < 0)
            {
                return;
            }

            string href = this.GetTrackHrefFromTag(this.dataGridViewTracks.Rows[e.RowIndex].Tag);
            this.SendToServer(href + "|Play");
        }

        /// <summary>
        /// Gets the track href from the given track tag
        /// </summary>
        /// <param name="tag">Track tag</param>
        /// <returns>Track href</returns>
        private string GetTrackHrefFromTag(object tag)
        {
            string href = string.Empty;
            if (tag is SearchTrack)
            {
                href = ((SearchTrack)tag).Href;
            }
            else if (tag is ArtistTrack)
            {
                href = ((ArtistTrack)tag).Href;
            }

            return href;
        }

        /// <summary>
        /// Gets the album uri for the given track tag
        /// </summary>
        /// <param name="tag">Track tag</param>
        /// <returns>Album uri</returns>
        private string GetAlbumUriFromTag(object tag)
        {
            string uri = string.Empty;
            if (tag is SearchTrack)
            {
                uri = ((SearchTrack)tag).Album.Href;
            }
            else if (tag is ArtistTrack)
            {
                // This happens when a user clicks the track name
                // It will bring up results for the album and highlight the track
                // Unfortunately, ArtistTrack objects don't contain the URI of the album on which they reside
                // As a result, clicking the name of the album won't do a new search
                // But that's okay because the user would get the exact same results
            }

            return uri;
        }

        /// <summary>
        /// Gets the artist uri from the given track tag
        /// </summary>
        /// <param name="tag">Track tag</param>
        /// <returns>Artist uri</returns>
        private string GetArtistUriFromTag(object tag)
        {
            string uri = string.Empty;
            if (tag is SearchTrack)
            {
                uri = ((SearchTrack)tag).Artist.Href;
            }
            else if (tag is ArtistTrack)
            {
                uri = ((ArtistTrack)tag).Artist.Href;
            }

            return uri;
        }

        /// <summary>
        /// pictureBox Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void pictureBox_Click(object sender, EventArgs e)
        {
            if (pictureBox.Image != null)
            {
                AlbumArtViewer arv = new AlbumArtViewer(this.currentStatus.Track.AlbumResource.ToString(), pictureBox.Image);
                arv.Show();
            }
        }

        /// <summary>
        /// toolStripSplitButtonSendTo ButtonClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void toolStripSplitButtonSendTo_ButtonClick(object sender, EventArgs e)
        {
            // TODO
        }

        /// <summary>
        /// linkLabelTrack LinkClicked event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelTrack_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            this.LookupAlbum(this.currentStatus.Track.AlbumResource.Uri, this.currentStatus.Track.TrackResource.Uri, this.currentStatus.Track.TrackResource.Name);
        }

        /// <summary>
        /// linkLabelArtist LinkClicked event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelArtist_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            this.Search(linkLabelArtist.Text, SearchType.Artist);
        }

        /// <summary>
        /// dataGridViewTracks SelectionChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_SelectionChanged(object sender, EventArgs e)
        {
            List<int> newSelectedTrackRowIndices = new List<int>();
            for (int i = 0; i < dataGridViewTracks.SelectedRows.Count; i++)
            {
                DataGridViewRow row = dataGridViewTracks.SelectedRows[i];
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).LinkColor = Color.FromKnownColor(KnownColor.HighlightText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).ActiveLinkColor = Color.FromKnownColor(KnownColor.HighlightText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).LinkColor = Color.FromKnownColor(KnownColor.HighlightText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).ActiveLinkColor = Color.FromKnownColor(KnownColor.HighlightText);

                DataGridViewImageCell pop = (DataGridViewImageCell)row.Cells[(int)TrackColumns.Popularity];
                pop.Value = this.GetPopularityImage((double)pop.Tag, selected: true);

                newSelectedTrackRowIndices.Add(row.Index);
            }

            this.selectedTrackRowIndices.RemoveAll(x => newSelectedTrackRowIndices.Contains(x));
            foreach (int i in this.selectedTrackRowIndices)
            {
                DataGridViewRow row = dataGridViewTracks.Rows[i];
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Artist]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)row.Cells[(int)TrackColumns.Album]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);

                DataGridViewImageCell pop = (DataGridViewImageCell)row.Cells[(int)TrackColumns.Popularity];
                pop.Value = this.GetPopularityImage((double)pop.Tag, selected: false);
            }

            this.selectedTrackRowIndices = newSelectedTrackRowIndices;
        }

        /// <summary>
        /// dataGridViewTracks RowLeave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_RowLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Artist, e.RowIndex]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Artist, e.RowIndex]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Album, e.RowIndex]).LinkColor = Color.FromKnownColor(KnownColor.ControlText);
                ((DataGridViewLinkCell)dataGridViewTracks[(int)TrackColumns.Album, e.RowIndex]).ActiveLinkColor = Color.FromKnownColor(KnownColor.ControlText);

                DataGridViewImageCell pop = (DataGridViewImageCell)dataGridViewTracks[(int)TrackColumns.Popularity, e.RowIndex];
                pop.Value = this.GetPopularityImage((double)pop.Tag, selected: false);
            }
        }

        /// <summary>
        /// dataGridViewTracks CellContentClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                if (e.ColumnIndex == (int)TrackColumns.Artist)
                {
                    this.Search(dataGridViewTracks[e.ColumnIndex, e.RowIndex].Value.ToString(), SearchType.Artist);
                }
                else if (e.ColumnIndex == (int)TrackColumns.Album)
                {
                    string uri = this.GetAlbumUriFromTag(this.dataGridViewTracks.Rows[e.RowIndex].Tag);
                    string name = this.dataGridViewTracks[(int)TrackColumns.Track, e.RowIndex].Value.ToString();
                    this.LookupAlbum(uri, this.GetTrackHrefFromTag(this.dataGridViewTracks.Rows[e.RowIndex].Tag), name);
                }
            }
        }

        /// <summary>
        /// dataGridViewTracks SortCompare event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_SortCompare(object sender, DataGridViewSortCompareEventArgs e)
        {
            if (e.Column.Index == (int)TrackColumns.Popularity)
            {
                e.SortResult = Convert.ToInt64(dataGridViewTracks[e.Column.Index, e.RowIndex1].Tag).CompareTo(Convert.ToInt64(dataGridViewTracks[e.Column.Index, e.RowIndex2].Tag));
            }
        }

        /// <summary>
        /// dataGridViewTracks ColumnHeaderMouseClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void dataGridViewTracks_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            Type type = typeof(string);
            switch (e.ColumnIndex)
            {
                case (int)TrackColumns.Album:
                case (int)TrackColumns.Artist:
                case (int)TrackColumns.Track:
                    type = typeof(string);
                    break;
                case (int)TrackColumns.Popularity:
                case (int)TrackColumns.Time:
                    type = typeof(double);
                    break;
            }

            // Remove sort glyph from all other headers
            foreach (DataGridViewColumn col in dataGridViewTracks.Columns)
            {
                if (col.Index != e.ColumnIndex)
                {
                    col.HeaderCell.SortGlyphDirection = System.Windows.Forms.SortOrder.None;
                }
            }

            System.Windows.Forms.SortOrder sortOrder = dataGridViewTracks.Columns[e.ColumnIndex].HeaderCell.SortGlyphDirection;
            if (sortOrder == System.Windows.Forms.SortOrder.Descending)
            {
                sortOrder = System.Windows.Forms.SortOrder.Ascending;
            }
            else
            {
                sortOrder = System.Windows.Forms.SortOrder.Descending;
            }

            dataGridViewTracks.Sort(new TrackRowComparer(e.ColumnIndex, sortOrder, type));
            dataGridViewTracks.Columns[e.ColumnIndex].HeaderCell.SortGlyphDirection = sortOrder;
        }

        /// <summary>
        /// linkLabelTrack MouseHover event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelTrack_MouseHover(object sender, EventArgs e)
        {
            this.tooltipTrack.Show(linkLabelTrack.Text, this.linkLabelTrack);
        }

        /// <summary>
        /// linkLabelArtist MouseHover event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void linkLabelArtist_MouseHover(object sender, EventArgs e)
        {
            this.tooltipArtist.Show(linkLabelArtist.Text, this.linkLabelArtist);
        }

        /// <summary>
        /// panelPlayPause MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelPlayPause.Capture = true;
            if (this.currentStatus.Playing)
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.PausePressed;
            }
            else
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.PlayPressed;
            }
        }

        /// <summary>
        /// panelPlayPause MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelPlayPause.Capture = false;
            if (this.currentStatus.Playing)
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.Pause;
            }
            else
            {
                this.panelPlayPause.BackgroundImage = Properties.Resources.Play;
            }
        }

        /// <summary>
        /// panelPrevious MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelPrevious.Capture = true;
            this.panelPrevious.BackgroundImage = Properties.Resources.PreviousPressed;
        }

        /// <summary>
        /// panelPrevious MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelPrevious.Capture = false;
            this.panelPrevious.BackgroundImage = Properties.Resources.Previous;
        }

        /// <summary>
        /// panelNext MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelNext.Capture = true;
            this.panelNext.BackgroundImage = Properties.Resources.NextPressed;
        }

        /// <summary>
        /// panelNext MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelNext.Capture = false;
            this.panelNext.BackgroundImage = Properties.Resources.Next;
        }

        /// <summary>
        /// panelPrevious Click
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPrevious_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Previous");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// panelPlayPause Click
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelPlayPause_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Pause");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// panelNext Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelNext_Click(object sender, EventArgs e)
        {
            try
            {
                this.SendToServer("|Next");
            }
            catch (SocketException se)
            {
                MessageBox.Show(se.Message);
            }
        }

        /// <summary>
        /// textBoxSearch Enter event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_Enter(object sender, EventArgs e)
        {
            this.panelSearch.BackgroundImage = Properties.Resources.SearchFocused;
            if (this.textBoxSearch.Text == "Search")
            {
                this.textBoxSearch.Text = string.Empty;
                this.textBoxSearch.ForeColor = Color.FromKnownColor(KnownColor.WindowText);
            }
        }

        /// <summary>
        /// textBoxSearch Leave event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_Leave(object sender, EventArgs e)
        {
            this.panelSearch.BackgroundImage = Properties.Resources.Search;
            if (string.IsNullOrEmpty(this.textBoxSearch.Text))
            {
                this.textBoxSearch.Text = "Search";
                this.textBoxSearch.ForeColor = (Color)this.textBoxSearch.Tag;
            }
        }

        /// <summary>
        /// textBoxSearch KeyDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void textBoxSearch_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                this.Search(textBoxSearch.Text);
                e.SuppressKeyPress = true;
                this.ActiveControl = this.panelPlayPause;
            }
        }

        /// <summary>
        /// splitterMain SplitterMoved event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void splitterMain_SplitterMoved(object sender, SplitterEventArgs e)
        {
            this.linkLabelTrack.MaximumSize = new Size(splitterMain.Location.X, this.linkLabelTrack.Height);
            this.linkLabelArtist.MaximumSize = new Size(splitterMain.Location.X, this.linkLabelArtist.Height);
            panelPicture.Height = splitterMain.Location.X;
        }

        /// <summary>
        /// SpotConForm Resize event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void SpotConForm_Resize(object sender, EventArgs e)
        {
            this.panelRepeat.Location = new Point(this.Width - 40, this.panelRepeat.Location.Y);
            this.panelShuffle.Location = new Point(this.panelRepeat.Location.X - 1, this.panelShuffle.Location.Y);
        }

        /// <summary>
        /// pictureBox SizeChanged event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void pictureBox_SizeChanged(object sender, EventArgs e)
        {
            this.MinimumSize = new Size(500, Math.Max(410, 410 + panelPicture.Height - 150));
        }

        /// <summary>
        /// panelVolumeKnob MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Tag = e.X;
            this.panelVolumeKnob.Capture = true;
        }

        /// <summary>
        /// panelVolumeKnob MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Capture = false;

            this.ChangeVolume();
        }

        /// <summary>
        /// Changes the volume
        /// </summary>
        private void ChangeVolume()
        {
            double level = (double)this.panelVolumeKnob.Left / (double)(this.panelVolume.Width - this.panelVolumeKnob.Width);
            this.SendToServer(level + ":" + this.currentStatus.Volume + "|SetVolume");
        }

        /// <summary>
        /// panelVolumeKnob MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolumeKnob_MouseMove(object sender, MouseEventArgs e)
        {
            if (this.panelVolumeKnob.Capture)
            {
                this.MoveVolumeKnob(e.X);
            }
        }

        /// <summary>
        /// Moves the volume knob to the given x-coordinate
        /// </summary>
        /// <param name="x">Coordinate to which to move the volume knob</param>
        private void MoveVolumeKnob(int x)
        {
            panelVolumeKnob.Left = Math.Min(Math.Max(0, x + this.panelVolumeKnob.Left - (this.panelVolumeKnob.Width / 2)), this.panelVolume.Width - this.panelVolumeKnob.Width);
        }

        /// <summary>
        /// panelVolume MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolume_MouseDown(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Tag = e.X;
            this.panelVolumeKnob.Capture = true;
            this.MoveVolumeKnob(e.X);
        }

        /// <summary>
        /// panelVolume MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelVolume_MouseUp(object sender, MouseEventArgs e)
        {
            this.panelVolumeKnob.Capture = false;
            this.ChangeVolume();
        }

        /// <summary>
        /// panelForward MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseMove(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                if (this.panelForward.Bounds.Contains(this.panelForward.Parent.PointToClient(Control.MousePosition)))
                {
                    this.panelForward.Capture = true;
                    this.panelForward.BackgroundImage = Properties.Resources.ForwardHover;
                }
                else
                {
                    this.panelForward.Capture = false;
                    this.panelForward.BackgroundImage = Properties.Resources.Forward;
                }
            }
        }

        /// <summary>
        /// panelBack MouseMove event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseMove(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                if (panelBack.Bounds.Contains(panelBack.Parent.PointToClient(Control.MousePosition)))
                {
                    this.panelBack.Capture = true;
                    this.panelBack.BackgroundImage = Properties.Resources.BackHover;
                }
                else
                {
                    this.panelBack.Capture = false;
                    this.panelBack.BackgroundImage = Properties.Resources.Back;
                }
            }
        }

        /// <summary>
        /// panelBack MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseDown(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                this.panelBack.BackgroundImage = Properties.Resources.BackClicked;
            }
        }

        /// <summary>
        /// panelForward MouseDown event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseDown(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                this.panelForward.BackgroundImage = Properties.Resources.ForwardClicked;
            }
        }

        /// <summary>
        /// panelBack MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseUp(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelBack.Tag)
            {
                this.panelBack.BackgroundImage = Properties.Resources.Back;
            }
        }

        /// <summary>
        /// panelForward MouseUp event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_MouseUp(object sender, MouseEventArgs e)
        {
            if ((bool)this.panelForward.Tag)
            {
                this.panelForward.BackgroundImage = Properties.Resources.Forward;
            }
        }

        /// <summary>
        /// panelBack MouseClick event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelBack_MouseClick(object sender, MouseEventArgs e)
        {
            this.GoBack();
        }

        /// <summary>
        /// panelForward Click event
        /// </summary>
        /// <param name="sender">What raised the event</param>
        /// <param name="e">Event arguments</param>
        private void panelForward_Click(object sender, EventArgs e)
        {
            this.GoForward();
        }

        /// <summary>
        /// Goes back in the history
        /// </summary>
        private void GoBack()
        {
            if ((bool)this.panelBack.Tag)
            {
                this.history[--this.historyIndex].Invoke();

                this.panelForward.Tag = true;
                this.panelForward.BackgroundImage = Properties.Resources.Forward;

                if (this.historyIndex == 0)
                {
                    this.panelBack.Tag = false;
                    this.panelBack.BackgroundImage = Properties.Resources.BackDisabled;
                }
            }
        }

        /// <summary>
        /// Goes forward in the history
        /// </summary>
        private void GoForward()
        {
            if ((bool)this.panelForward.Tag)
            {
                this.history[++this.historyIndex].Invoke();

                this.panelBack.Tag = true;
                this.panelBack.BackgroundImage = Properties.Resources.Back;

                if (this.historyIndex == this.history.Count - 1)
                {
                    this.panelForward.Tag = false;
                    this.panelForward.BackgroundImage = Properties.Resources.ForwardDisabled;
                }
            }
        }

        /// <summary>
        /// Represents a packet
        /// </summary>
        public class SocketPacket
        {
            /// <summary>
            /// Initializes a new instance of the SocketPacket class
            /// </summary>
            public SocketPacket()
            {
                this.Buffer = new byte[1];
            }

            /// <summary>
            /// Gets or sets the corresponding socket
            /// </summary>
            public Socket Socket { get; set; }

            /// <summary>
            /// Gets or sets the buffer to store packet data
            /// </summary>
            public byte[] Buffer { get; set; }
        }

        /// <summary>
        /// Represents host information
        /// </summary>
        public class HostData
        {
            /// <summary>
            /// Gets or sets the hosts' IP address
            /// </summary>
            public IPAddress IPAddress { get; set; }

            /// <summary>
            /// Gets or sets the host's associated socket
            /// </summary>
            public Socket Socket { get; set; }

            /// <summary>
            /// Gets or sets the hosts' connection status
            /// </summary>
            public ClientConnectStatus ConnectionStatus { get; set; }

            /// <summary>
            /// Gets or sets the associated row in the host data grid
            /// </summary>
            public DataGridViewRow Row { get; set; }

            /// <summary>
            /// Gets or sets the timer used to update the Spotify status
            /// </summary>
            public Timer Timer { get; set; }
        }
    }
}